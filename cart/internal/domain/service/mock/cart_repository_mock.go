// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/domain/service.CartsRepository -o cart_repository_mock.go -n CartsRepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartsRepositoryMock implements mm_service.CartsRepository
type CartsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, userID model.UserID, item model.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartsRepositoryMockAddItem

	funcDeleteItem          func(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, userID model.UserID, item model.Item)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartsRepositoryMockDeleteItem

	funcDeleteItems          func(ctx context.Context, userID model.UserID) (u1 model.UserID, err error)
	funcDeleteItemsOrigin    string
	inspectFuncDeleteItems   func(ctx context.Context, userID model.UserID)
	afterDeleteItemsCounter  uint64
	beforeDeleteItemsCounter uint64
	DeleteItemsMock          mCartsRepositoryMockDeleteItems

	funcGetCart          func(ctx context.Context, userID model.UserID) (cp1 *model.Cart, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, userID model.UserID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartsRepositoryMockGetCart
}

// NewCartsRepositoryMock returns a mock for mm_service.CartsRepository
func NewCartsRepositoryMock(t minimock.Tester) *CartsRepositoryMock {
	m := &CartsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartsRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartsRepositoryMockAddItemParams{}

	m.DeleteItemMock = mCartsRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartsRepositoryMockDeleteItemParams{}

	m.DeleteItemsMock = mCartsRepositoryMockDeleteItems{mock: m}
	m.DeleteItemsMock.callArgs = []*CartsRepositoryMockDeleteItemsParams{}

	m.GetCartMock = mCartsRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartsRepositoryMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartsRepositoryMockAddItem struct {
	optional           bool
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockAddItemExpectation
	expectations       []*CartsRepositoryMockAddItemExpectation

	callArgs []*CartsRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartsRepositoryMockAddItemExpectation specifies expectation struct of the CartsRepository.AddItem
type CartsRepositoryMockAddItemExpectation struct {
	mock               *CartsRepositoryMock
	params             *CartsRepositoryMockAddItemParams
	paramPtrs          *CartsRepositoryMockAddItemParamPtrs
	expectationOrigins CartsRepositoryMockAddItemExpectationOrigins
	results            *CartsRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartsRepositoryMockAddItemParams contains parameters of the CartsRepository.AddItem
type CartsRepositoryMockAddItemParams struct {
	ctx    context.Context
	userID model.UserID
	item   model.Item
}

// CartsRepositoryMockAddItemParamPtrs contains pointers to parameters of the CartsRepository.AddItem
type CartsRepositoryMockAddItemParamPtrs struct {
	ctx    *context.Context
	userID *model.UserID
	item   *model.Item
}

// CartsRepositoryMockAddItemResults contains results of the CartsRepository.AddItem
type CartsRepositoryMockAddItemResults struct {
	ip1 *model.Item
	err error
}

// CartsRepositoryMockAddItemOrigins contains origins of expectations of the CartsRepository.AddItem
type CartsRepositoryMockAddItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItem   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartsRepositoryMockAddItem) Optional() *mCartsRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) Expect(ctx context.Context, userID model.UserID, item model.Item) *mCartsRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartsRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartsRepositoryMockAddItemParams{ctx, userID, item}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mCartsRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartsRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartsRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectUserIDParam2 sets up expected param userID for CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) ExpectUserIDParam2(userID model.UserID) *mCartsRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartsRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartsRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userID = &userID
	mmAddItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectItemParam3 sets up expected param item for CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) ExpectItemParam3(item model.Item) *mCartsRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartsRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartsRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item
	mmAddItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) Inspect(f func(ctx context.Context, userID model.UserID, item model.Item)) *mCartsRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartsRepository.AddItem
func (mmAddItem *mCartsRepositoryMockAddItem) Return(ip1 *model.Item, err error) *CartsRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartsRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartsRepositoryMockAddItemResults{ip1, err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartsRepository.AddItem method
func (mmAddItem *mCartsRepositoryMockAddItem) Set(f func(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error)) *CartsRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartsRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartsRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartsRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartsRepositoryMockAddItem) When(ctx context.Context, userID model.UserID, item model.Item) *CartsRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartsRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &CartsRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartsRepositoryMockAddItemParams{ctx, userID, item},
		expectationOrigins: CartsRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockAddItemExpectation) Then(ip1 *model.Item, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockAddItemResults{ip1, err}
	return e.mock
}

// Times sets number of times CartsRepository.AddItem should be invoked
func (mmAddItem *mCartsRepositoryMockAddItem) Times(n uint64) *mCartsRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartsRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartsRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_service.CartsRepository
func (mmAddItem *CartsRepositoryMock) AddItem(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, item)
	}

	mm_params := CartsRepositoryMockAddItemParams{ctx, userID, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartsRepositoryMockAddItemParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("CartsRepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItem.t.Errorf("CartsRepositoryMock.AddItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("CartsRepositoryMock.AddItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartsRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartsRepositoryMock.AddItem")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartsRepositoryMock.AddItem. %v %v %v", ctx, userID, item)
	return
}

// AddItemAfterCounter returns a count of finished CartsRepositoryMock.AddItem invocations
func (mmAddItem *CartsRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartsRepositoryMock.AddItem invocations
func (mmAddItem *CartsRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartsRepositoryMockAddItem) Calls() []*CartsRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartsRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartsRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartsRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartsRepositoryMockDeleteItem struct {
	optional           bool
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockDeleteItemExpectation
	expectations       []*CartsRepositoryMockDeleteItemExpectation

	callArgs []*CartsRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartsRepositoryMockDeleteItemExpectation specifies expectation struct of the CartsRepository.DeleteItem
type CartsRepositoryMockDeleteItemExpectation struct {
	mock               *CartsRepositoryMock
	params             *CartsRepositoryMockDeleteItemParams
	paramPtrs          *CartsRepositoryMockDeleteItemParamPtrs
	expectationOrigins CartsRepositoryMockDeleteItemExpectationOrigins
	results            *CartsRepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// CartsRepositoryMockDeleteItemParams contains parameters of the CartsRepository.DeleteItem
type CartsRepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userID model.UserID
	item   model.Item
}

// CartsRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the CartsRepository.DeleteItem
type CartsRepositoryMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *model.UserID
	item   *model.Item
}

// CartsRepositoryMockDeleteItemResults contains results of the CartsRepository.DeleteItem
type CartsRepositoryMockDeleteItemResults struct {
	ip1 *model.Item
	err error
}

// CartsRepositoryMockDeleteItemOrigins contains origins of expectations of the CartsRepository.DeleteItem
type CartsRepositoryMockDeleteItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItem   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Optional() *mCartsRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Expect(ctx context.Context, userID model.UserID, item model.Item) *mCartsRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartsRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartsRepositoryMockDeleteItemParams{ctx, userID, item}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mCartsRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartsRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartsRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) ExpectUserIDParam2(userID model.UserID) *mCartsRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartsRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartsRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectItemParam3 sets up expected param item for CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) ExpectItemParam3(item model.Item) *mCartsRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartsRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartsRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.item = &item
	mmDeleteItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userID model.UserID, item model.Item)) *mCartsRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartsRepository.DeleteItem
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Return(ip1 *model.Item, err error) *CartsRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartsRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartsRepositoryMockDeleteItemResults{ip1, err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartsRepository.DeleteItem method
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Set(f func(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error)) *CartsRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartsRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartsRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the CartsRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) When(ctx context.Context, userID model.UserID, item model.Item) *CartsRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartsRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartsRepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &CartsRepositoryMockDeleteItemParams{ctx, userID, item},
		expectationOrigins: CartsRepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockDeleteItemExpectation) Then(ip1 *model.Item, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockDeleteItemResults{ip1, err}
	return e.mock
}

// Times sets number of times CartsRepository.DeleteItem should be invoked
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Times(n uint64) *mCartsRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartsRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mCartsRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_service.CartsRepository
func (mmDeleteItem *CartsRepositoryMock) DeleteItem(ctx context.Context, userID model.UserID, item model.Item) (ip1 *model.Item, err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, item)
	}

	mm_params := CartsRepositoryMockDeleteItemParams{ctx, userID, item}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartsRepositoryMockDeleteItemParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("CartsRepositoryMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("CartsRepositoryMock.DeleteItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmDeleteItem.t.Errorf("CartsRepositoryMock.DeleteItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartsRepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartsRepositoryMock.DeleteItem")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, item)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartsRepositoryMock.DeleteItem. %v %v %v", ctx, userID, item)
	return
}

// DeleteItemAfterCounter returns a count of finished CartsRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartsRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartsRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartsRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartsRepositoryMockDeleteItem) Calls() []*CartsRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartsRepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mCartsRepositoryMockDeleteItems struct {
	optional           bool
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockDeleteItemsExpectation
	expectations       []*CartsRepositoryMockDeleteItemsExpectation

	callArgs []*CartsRepositoryMockDeleteItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartsRepositoryMockDeleteItemsExpectation specifies expectation struct of the CartsRepository.DeleteItems
type CartsRepositoryMockDeleteItemsExpectation struct {
	mock               *CartsRepositoryMock
	params             *CartsRepositoryMockDeleteItemsParams
	paramPtrs          *CartsRepositoryMockDeleteItemsParamPtrs
	expectationOrigins CartsRepositoryMockDeleteItemsExpectationOrigins
	results            *CartsRepositoryMockDeleteItemsResults
	returnOrigin       string
	Counter            uint64
}

// CartsRepositoryMockDeleteItemsParams contains parameters of the CartsRepository.DeleteItems
type CartsRepositoryMockDeleteItemsParams struct {
	ctx    context.Context
	userID model.UserID
}

// CartsRepositoryMockDeleteItemsParamPtrs contains pointers to parameters of the CartsRepository.DeleteItems
type CartsRepositoryMockDeleteItemsParamPtrs struct {
	ctx    *context.Context
	userID *model.UserID
}

// CartsRepositoryMockDeleteItemsResults contains results of the CartsRepository.DeleteItems
type CartsRepositoryMockDeleteItemsResults struct {
	u1  model.UserID
	err error
}

// CartsRepositoryMockDeleteItemsOrigins contains origins of expectations of the CartsRepository.DeleteItems
type CartsRepositoryMockDeleteItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Optional() *mCartsRepositoryMockDeleteItems {
	mmDeleteItems.optional = true
	return mmDeleteItems
}

// Expect sets up expected params for CartsRepository.DeleteItems
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Expect(ctx context.Context, userID model.UserID) *mCartsRepositoryMockDeleteItems {
	if mmDeleteItems.mock.funcDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Set")
	}

	if mmDeleteItems.defaultExpectation == nil {
		mmDeleteItems.defaultExpectation = &CartsRepositoryMockDeleteItemsExpectation{}
	}

	if mmDeleteItems.defaultExpectation.paramPtrs != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by ExpectParams functions")
	}

	mmDeleteItems.defaultExpectation.params = &CartsRepositoryMockDeleteItemsParams{ctx, userID}
	mmDeleteItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItems.expectations {
		if minimock.Equal(e.params, mmDeleteItems.defaultExpectation.params) {
			mmDeleteItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItems.defaultExpectation.params)
		}
	}

	return mmDeleteItems
}

// ExpectCtxParam1 sets up expected param ctx for CartsRepository.DeleteItems
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) ExpectCtxParam1(ctx context.Context) *mCartsRepositoryMockDeleteItems {
	if mmDeleteItems.mock.funcDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Set")
	}

	if mmDeleteItems.defaultExpectation == nil {
		mmDeleteItems.defaultExpectation = &CartsRepositoryMockDeleteItemsExpectation{}
	}

	if mmDeleteItems.defaultExpectation.params != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Expect")
	}

	if mmDeleteItems.defaultExpectation.paramPtrs == nil {
		mmDeleteItems.defaultExpectation.paramPtrs = &CartsRepositoryMockDeleteItemsParamPtrs{}
	}
	mmDeleteItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItems
}

// ExpectUserIDParam2 sets up expected param userID for CartsRepository.DeleteItems
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) ExpectUserIDParam2(userID model.UserID) *mCartsRepositoryMockDeleteItems {
	if mmDeleteItems.mock.funcDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Set")
	}

	if mmDeleteItems.defaultExpectation == nil {
		mmDeleteItems.defaultExpectation = &CartsRepositoryMockDeleteItemsExpectation{}
	}

	if mmDeleteItems.defaultExpectation.params != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Expect")
	}

	if mmDeleteItems.defaultExpectation.paramPtrs == nil {
		mmDeleteItems.defaultExpectation.paramPtrs = &CartsRepositoryMockDeleteItemsParamPtrs{}
	}
	mmDeleteItems.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItems
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.DeleteItems
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Inspect(f func(ctx context.Context, userID model.UserID)) *mCartsRepositoryMockDeleteItems {
	if mmDeleteItems.mock.inspectFuncDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.DeleteItems")
	}

	mmDeleteItems.mock.inspectFuncDeleteItems = f

	return mmDeleteItems
}

// Return sets up results that will be returned by CartsRepository.DeleteItems
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Return(u1 model.UserID, err error) *CartsRepositoryMock {
	if mmDeleteItems.mock.funcDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Set")
	}

	if mmDeleteItems.defaultExpectation == nil {
		mmDeleteItems.defaultExpectation = &CartsRepositoryMockDeleteItemsExpectation{mock: mmDeleteItems.mock}
	}
	mmDeleteItems.defaultExpectation.results = &CartsRepositoryMockDeleteItemsResults{u1, err}
	mmDeleteItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItems.mock
}

// Set uses given function f to mock the CartsRepository.DeleteItems method
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Set(f func(ctx context.Context, userID model.UserID) (u1 model.UserID, err error)) *CartsRepositoryMock {
	if mmDeleteItems.defaultExpectation != nil {
		mmDeleteItems.mock.t.Fatalf("Default expectation is already set for the CartsRepository.DeleteItems method")
	}

	if len(mmDeleteItems.expectations) > 0 {
		mmDeleteItems.mock.t.Fatalf("Some expectations are already set for the CartsRepository.DeleteItems method")
	}

	mmDeleteItems.mock.funcDeleteItems = f
	mmDeleteItems.mock.funcDeleteItemsOrigin = minimock.CallerInfo(1)
	return mmDeleteItems.mock
}

// When sets expectation for the CartsRepository.DeleteItems which will trigger the result defined by the following
// Then helper
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) When(ctx context.Context, userID model.UserID) *CartsRepositoryMockDeleteItemsExpectation {
	if mmDeleteItems.mock.funcDeleteItems != nil {
		mmDeleteItems.mock.t.Fatalf("CartsRepositoryMock.DeleteItems mock is already set by Set")
	}

	expectation := &CartsRepositoryMockDeleteItemsExpectation{
		mock:               mmDeleteItems.mock,
		params:             &CartsRepositoryMockDeleteItemsParams{ctx, userID},
		expectationOrigins: CartsRepositoryMockDeleteItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItems.expectations = append(mmDeleteItems.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.DeleteItems return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockDeleteItemsExpectation) Then(u1 model.UserID, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockDeleteItemsResults{u1, err}
	return e.mock
}

// Times sets number of times CartsRepository.DeleteItems should be invoked
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Times(n uint64) *mCartsRepositoryMockDeleteItems {
	if n == 0 {
		mmDeleteItems.mock.t.Fatalf("Times of CartsRepositoryMock.DeleteItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItems.expectedInvocations, n)
	mmDeleteItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItems
}

func (mmDeleteItems *mCartsRepositoryMockDeleteItems) invocationsDone() bool {
	if len(mmDeleteItems.expectations) == 0 && mmDeleteItems.defaultExpectation == nil && mmDeleteItems.mock.funcDeleteItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItems.mock.afterDeleteItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItems implements mm_service.CartsRepository
func (mmDeleteItems *CartsRepositoryMock) DeleteItems(ctx context.Context, userID model.UserID) (u1 model.UserID, err error) {
	mm_atomic.AddUint64(&mmDeleteItems.beforeDeleteItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItems.afterDeleteItemsCounter, 1)

	mmDeleteItems.t.Helper()

	if mmDeleteItems.inspectFuncDeleteItems != nil {
		mmDeleteItems.inspectFuncDeleteItems(ctx, userID)
	}

	mm_params := CartsRepositoryMockDeleteItemsParams{ctx, userID}

	// Record call args
	mmDeleteItems.DeleteItemsMock.mutex.Lock()
	mmDeleteItems.DeleteItemsMock.callArgs = append(mmDeleteItems.DeleteItemsMock.callArgs, &mm_params)
	mmDeleteItems.DeleteItemsMock.mutex.Unlock()

	for _, e := range mmDeleteItems.DeleteItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmDeleteItems.DeleteItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItems.DeleteItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItems.DeleteItemsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItems.DeleteItemsMock.defaultExpectation.paramPtrs

		mm_got := CartsRepositoryMockDeleteItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItems.t.Errorf("CartsRepositoryMock.DeleteItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItems.DeleteItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItems.t.Errorf("CartsRepositoryMock.DeleteItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItems.DeleteItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItems.t.Errorf("CartsRepositoryMock.DeleteItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItems.DeleteItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItems.DeleteItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItems.t.Fatal("No results are set for the CartsRepositoryMock.DeleteItems")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmDeleteItems.funcDeleteItems != nil {
		return mmDeleteItems.funcDeleteItems(ctx, userID)
	}
	mmDeleteItems.t.Fatalf("Unexpected call to CartsRepositoryMock.DeleteItems. %v %v", ctx, userID)
	return
}

// DeleteItemsAfterCounter returns a count of finished CartsRepositoryMock.DeleteItems invocations
func (mmDeleteItems *CartsRepositoryMock) DeleteItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItems.afterDeleteItemsCounter)
}

// DeleteItemsBeforeCounter returns a count of CartsRepositoryMock.DeleteItems invocations
func (mmDeleteItems *CartsRepositoryMock) DeleteItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItems.beforeDeleteItemsCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.DeleteItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItems *mCartsRepositoryMockDeleteItems) Calls() []*CartsRepositoryMockDeleteItemsParams {
	mmDeleteItems.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockDeleteItemsParams, len(mmDeleteItems.callArgs))
	copy(argCopy, mmDeleteItems.callArgs)

	mmDeleteItems.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsDone returns true if the count of the DeleteItems invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockDeleteItemsDone() bool {
	if m.DeleteItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsMock.invocationsDone()
}

// MinimockDeleteItemsInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockDeleteItemsInspect() {
	for _, e := range m.DeleteItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsMock.defaultExpectation != nil && afterDeleteItemsCounter < 1 {
		if m.DeleteItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItems at\n%s", m.DeleteItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItems at\n%s with params: %#v", m.DeleteItemsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItems != nil && afterDeleteItemsCounter < 1 {
		m.t.Errorf("Expected call to CartsRepositoryMock.DeleteItems at\n%s", m.funcDeleteItemsOrigin)
	}

	if !m.DeleteItemsMock.invocationsDone() && afterDeleteItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to CartsRepositoryMock.DeleteItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsMock.expectedInvocations), m.DeleteItemsMock.expectedInvocationsOrigin, afterDeleteItemsCounter)
	}
}

type mCartsRepositoryMockGetCart struct {
	optional           bool
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockGetCartExpectation
	expectations       []*CartsRepositoryMockGetCartExpectation

	callArgs []*CartsRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartsRepositoryMockGetCartExpectation specifies expectation struct of the CartsRepository.GetCart
type CartsRepositoryMockGetCartExpectation struct {
	mock               *CartsRepositoryMock
	params             *CartsRepositoryMockGetCartParams
	paramPtrs          *CartsRepositoryMockGetCartParamPtrs
	expectationOrigins CartsRepositoryMockGetCartExpectationOrigins
	results            *CartsRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartsRepositoryMockGetCartParams contains parameters of the CartsRepository.GetCart
type CartsRepositoryMockGetCartParams struct {
	ctx    context.Context
	userID model.UserID
}

// CartsRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartsRepository.GetCart
type CartsRepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userID *model.UserID
}

// CartsRepositoryMockGetCartResults contains results of the CartsRepository.GetCart
type CartsRepositoryMockGetCartResults struct {
	cp1 *model.Cart
	err error
}

// CartsRepositoryMockGetCartOrigins contains origins of expectations of the CartsRepository.GetCart
type CartsRepositoryMockGetCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartsRepositoryMockGetCart) Optional() *mCartsRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Expect(ctx context.Context, userID model.UserID) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartsRepositoryMockGetCartParams{ctx, userID}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartsRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectUserIDParam2 sets up expected param userID for CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) ExpectUserIDParam2(userID model.UserID) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartsRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID
	mmGetCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Inspect(f func(ctx context.Context, userID model.UserID)) *mCartsRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartsRepository.GetCart
func (mmGetCart *mCartsRepositoryMockGetCart) Return(cp1 *model.Cart, err error) *CartsRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartsRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartsRepositoryMockGetCartResults{cp1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartsRepository.GetCart method
func (mmGetCart *mCartsRepositoryMockGetCart) Set(f func(ctx context.Context, userID model.UserID) (cp1 *model.Cart, err error)) *CartsRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartsRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartsRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartsRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartsRepositoryMockGetCart) When(ctx context.Context, userID model.UserID) *CartsRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartsRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartsRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartsRepositoryMockGetCartParams{ctx, userID},
		expectationOrigins: CartsRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockGetCartExpectation) Then(cp1 *model.Cart, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockGetCartResults{cp1, err}
	return e.mock
}

// Times sets number of times CartsRepository.GetCart should be invoked
func (mmGetCart *mCartsRepositoryMockGetCart) Times(n uint64) *mCartsRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartsRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartsRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_service.CartsRepository
func (mmGetCart *CartsRepositoryMock) GetCart(ctx context.Context, userID model.UserID) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userID)
	}

	mm_params := CartsRepositoryMockGetCartParams{ctx, userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartsRepositoryMockGetCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartsRepositoryMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("CartsRepositoryMock.GetCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartsRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartsRepositoryMock.GetCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartsRepositoryMock.GetCart. %v %v", ctx, userID)
	return
}

// GetCartAfterCounter returns a count of finished CartsRepositoryMock.GetCart invocations
func (mmGetCart *CartsRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartsRepositoryMock.GetCart invocations
func (mmGetCart *CartsRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartsRepositoryMockGetCart) Calls() []*CartsRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartsRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartsRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsDone() &&
		m.MinimockGetCartDone()
}
