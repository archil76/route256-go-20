// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/app/server.LomsServise -o loms_servise_mock.go -n LomsServiseMock -p mock

import (
	"context"
	"route256/loms/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LomsServiseMock implements mm_server.LomsServise
type LomsServiseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCancel          func(ctx context.Context, orderId int64) (err error)
	funcOrderCancelOrigin    string
	inspectFuncOrderCancel   func(ctx context.Context, orderId int64)
	afterOrderCancelCounter  uint64
	beforeOrderCancelCounter uint64
	OrderCancelMock          mLomsServiseMockOrderCancel

	funcOrderCreate          func(ctx context.Context, userID int64, items []model.Item) (i1 int64, err error)
	funcOrderCreateOrigin    string
	inspectFuncOrderCreate   func(ctx context.Context, userID int64, items []model.Item)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mLomsServiseMockOrderCreate

	funcOrderInfo          func(ctx context.Context, orderId int64) (op1 *model.Order, err error)
	funcOrderInfoOrigin    string
	inspectFuncOrderInfo   func(ctx context.Context, orderId int64)
	afterOrderInfoCounter  uint64
	beforeOrderInfoCounter uint64
	OrderInfoMock          mLomsServiseMockOrderInfo

	funcOrderPay          func(ctx context.Context, orderId int64) (err error)
	funcOrderPayOrigin    string
	inspectFuncOrderPay   func(ctx context.Context, orderId int64)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mLomsServiseMockOrderPay

	funcStocksInfo          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcStocksInfoOrigin    string
	inspectFuncStocksInfo   func(ctx context.Context, sku int64)
	afterStocksInfoCounter  uint64
	beforeStocksInfoCounter uint64
	StocksInfoMock          mLomsServiseMockStocksInfo
}

// NewLomsServiseMock returns a mock for mm_server.LomsServise
func NewLomsServiseMock(t minimock.Tester) *LomsServiseMock {
	m := &LomsServiseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCancelMock = mLomsServiseMockOrderCancel{mock: m}
	m.OrderCancelMock.callArgs = []*LomsServiseMockOrderCancelParams{}

	m.OrderCreateMock = mLomsServiseMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*LomsServiseMockOrderCreateParams{}

	m.OrderInfoMock = mLomsServiseMockOrderInfo{mock: m}
	m.OrderInfoMock.callArgs = []*LomsServiseMockOrderInfoParams{}

	m.OrderPayMock = mLomsServiseMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*LomsServiseMockOrderPayParams{}

	m.StocksInfoMock = mLomsServiseMockStocksInfo{mock: m}
	m.StocksInfoMock.callArgs = []*LomsServiseMockStocksInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLomsServiseMockOrderCancel struct {
	optional           bool
	mock               *LomsServiseMock
	defaultExpectation *LomsServiseMockOrderCancelExpectation
	expectations       []*LomsServiseMockOrderCancelExpectation

	callArgs []*LomsServiseMockOrderCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiseMockOrderCancelExpectation specifies expectation struct of the LomsServise.OrderCancel
type LomsServiseMockOrderCancelExpectation struct {
	mock               *LomsServiseMock
	params             *LomsServiseMockOrderCancelParams
	paramPtrs          *LomsServiseMockOrderCancelParamPtrs
	expectationOrigins LomsServiseMockOrderCancelExpectationOrigins
	results            *LomsServiseMockOrderCancelResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiseMockOrderCancelParams contains parameters of the LomsServise.OrderCancel
type LomsServiseMockOrderCancelParams struct {
	ctx     context.Context
	orderId int64
}

// LomsServiseMockOrderCancelParamPtrs contains pointers to parameters of the LomsServise.OrderCancel
type LomsServiseMockOrderCancelParamPtrs struct {
	ctx     *context.Context
	orderId *int64
}

// LomsServiseMockOrderCancelResults contains results of the LomsServise.OrderCancel
type LomsServiseMockOrderCancelResults struct {
	err error
}

// LomsServiseMockOrderCancelOrigins contains origins of expectations of the LomsServise.OrderCancel
type LomsServiseMockOrderCancelExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCancel *mLomsServiseMockOrderCancel) Optional() *mLomsServiseMockOrderCancel {
	mmOrderCancel.optional = true
	return mmOrderCancel
}

// Expect sets up expected params for LomsServise.OrderCancel
func (mmOrderCancel *mLomsServiseMockOrderCancel) Expect(ctx context.Context, orderId int64) *mLomsServiseMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiseMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.paramPtrs != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by ExpectParams functions")
	}

	mmOrderCancel.defaultExpectation.params = &LomsServiseMockOrderCancelParams{ctx, orderId}
	mmOrderCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCancel.expectations {
		if minimock.Equal(e.params, mmOrderCancel.defaultExpectation.params) {
			mmOrderCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancel.defaultExpectation.params)
		}
	}

	return mmOrderCancel
}

// ExpectCtxParam1 sets up expected param ctx for LomsServise.OrderCancel
func (mmOrderCancel *mLomsServiseMockOrderCancel) ExpectCtxParam1(ctx context.Context) *mLomsServiseMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiseMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServiseMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCancel
}

// ExpectOrderIdParam2 sets up expected param orderId for LomsServise.OrderCancel
func (mmOrderCancel *mLomsServiseMockOrderCancel) ExpectOrderIdParam2(orderId int64) *mLomsServiseMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiseMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServiseMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.orderId = &orderId
	mmOrderCancel.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmOrderCancel
}

// Inspect accepts an inspector function that has same arguments as the LomsServise.OrderCancel
func (mmOrderCancel *mLomsServiseMockOrderCancel) Inspect(f func(ctx context.Context, orderId int64)) *mLomsServiseMockOrderCancel {
	if mmOrderCancel.mock.inspectFuncOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("Inspect function is already set for LomsServiseMock.OrderCancel")
	}

	mmOrderCancel.mock.inspectFuncOrderCancel = f

	return mmOrderCancel
}

// Return sets up results that will be returned by LomsServise.OrderCancel
func (mmOrderCancel *mLomsServiseMockOrderCancel) Return(err error) *LomsServiseMock {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiseMockOrderCancelExpectation{mock: mmOrderCancel.mock}
	}
	mmOrderCancel.defaultExpectation.results = &LomsServiseMockOrderCancelResults{err}
	mmOrderCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCancel.mock
}

// Set uses given function f to mock the LomsServise.OrderCancel method
func (mmOrderCancel *mLomsServiseMockOrderCancel) Set(f func(ctx context.Context, orderId int64) (err error)) *LomsServiseMock {
	if mmOrderCancel.defaultExpectation != nil {
		mmOrderCancel.mock.t.Fatalf("Default expectation is already set for the LomsServise.OrderCancel method")
	}

	if len(mmOrderCancel.expectations) > 0 {
		mmOrderCancel.mock.t.Fatalf("Some expectations are already set for the LomsServise.OrderCancel method")
	}

	mmOrderCancel.mock.funcOrderCancel = f
	mmOrderCancel.mock.funcOrderCancelOrigin = minimock.CallerInfo(1)
	return mmOrderCancel.mock
}

// When sets expectation for the LomsServise.OrderCancel which will trigger the result defined by the following
// Then helper
func (mmOrderCancel *mLomsServiseMockOrderCancel) When(ctx context.Context, orderId int64) *LomsServiseMockOrderCancelExpectation {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiseMock.OrderCancel mock is already set by Set")
	}

	expectation := &LomsServiseMockOrderCancelExpectation{
		mock:               mmOrderCancel.mock,
		params:             &LomsServiseMockOrderCancelParams{ctx, orderId},
		expectationOrigins: LomsServiseMockOrderCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCancel.expectations = append(mmOrderCancel.expectations, expectation)
	return expectation
}

// Then sets up LomsServise.OrderCancel return parameters for the expectation previously defined by the When method
func (e *LomsServiseMockOrderCancelExpectation) Then(err error) *LomsServiseMock {
	e.results = &LomsServiseMockOrderCancelResults{err}
	return e.mock
}

// Times sets number of times LomsServise.OrderCancel should be invoked
func (mmOrderCancel *mLomsServiseMockOrderCancel) Times(n uint64) *mLomsServiseMockOrderCancel {
	if n == 0 {
		mmOrderCancel.mock.t.Fatalf("Times of LomsServiseMock.OrderCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCancel.expectedInvocations, n)
	mmOrderCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCancel
}

func (mmOrderCancel *mLomsServiseMockOrderCancel) invocationsDone() bool {
	if len(mmOrderCancel.expectations) == 0 && mmOrderCancel.defaultExpectation == nil && mmOrderCancel.mock.funcOrderCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCancel.mock.afterOrderCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCancel implements mm_server.LomsServise
func (mmOrderCancel *LomsServiseMock) OrderCancel(ctx context.Context, orderId int64) (err error) {
	mm_atomic.AddUint64(&mmOrderCancel.beforeOrderCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancel.afterOrderCancelCounter, 1)

	mmOrderCancel.t.Helper()

	if mmOrderCancel.inspectFuncOrderCancel != nil {
		mmOrderCancel.inspectFuncOrderCancel(ctx, orderId)
	}

	mm_params := LomsServiseMockOrderCancelParams{ctx, orderId}

	// Record call args
	mmOrderCancel.OrderCancelMock.mutex.Lock()
	mmOrderCancel.OrderCancelMock.callArgs = append(mmOrderCancel.OrderCancelMock.callArgs, &mm_params)
	mmOrderCancel.OrderCancelMock.mutex.Unlock()

	for _, e := range mmOrderCancel.OrderCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderCancel.OrderCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancel.OrderCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancel.OrderCancelMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCancel.OrderCancelMock.defaultExpectation.paramPtrs

		mm_got := LomsServiseMockOrderCancelParams{ctx, orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCancel.t.Errorf("LomsServiseMock.OrderCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmOrderCancel.t.Errorf("LomsServiseMock.OrderCancel got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancel.t.Errorf("LomsServiseMock.OrderCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancel.OrderCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancel.t.Fatal("No results are set for the LomsServiseMock.OrderCancel")
		}
		return (*mm_results).err
	}
	if mmOrderCancel.funcOrderCancel != nil {
		return mmOrderCancel.funcOrderCancel(ctx, orderId)
	}
	mmOrderCancel.t.Fatalf("Unexpected call to LomsServiseMock.OrderCancel. %v %v", ctx, orderId)
	return
}

// OrderCancelAfterCounter returns a count of finished LomsServiseMock.OrderCancel invocations
func (mmOrderCancel *LomsServiseMock) OrderCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.afterOrderCancelCounter)
}

// OrderCancelBeforeCounter returns a count of LomsServiseMock.OrderCancel invocations
func (mmOrderCancel *LomsServiseMock) OrderCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.beforeOrderCancelCounter)
}

// Calls returns a list of arguments used in each call to LomsServiseMock.OrderCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancel *mLomsServiseMockOrderCancel) Calls() []*LomsServiseMockOrderCancelParams {
	mmOrderCancel.mutex.RLock()

	argCopy := make([]*LomsServiseMockOrderCancelParams, len(mmOrderCancel.callArgs))
	copy(argCopy, mmOrderCancel.callArgs)

	mmOrderCancel.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelDone returns true if the count of the OrderCancel invocations corresponds
// the number of defined expectations
func (m *LomsServiseMock) MinimockOrderCancelDone() bool {
	if m.OrderCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCancelMock.invocationsDone()
}

// MinimockOrderCancelInspect logs each unmet expectation
func (m *LomsServiseMock) MinimockOrderCancelInspect() {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCancelCounter := mm_atomic.LoadUint64(&m.afterOrderCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && afterOrderCancelCounter < 1 {
		if m.OrderCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCancel at\n%s", m.OrderCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCancel at\n%s with params: %#v", m.OrderCancelMock.defaultExpectation.expectationOrigins.origin, *m.OrderCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && afterOrderCancelCounter < 1 {
		m.t.Errorf("Expected call to LomsServiseMock.OrderCancel at\n%s", m.funcOrderCancelOrigin)
	}

	if !m.OrderCancelMock.invocationsDone() && afterOrderCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiseMock.OrderCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCancelMock.expectedInvocations), m.OrderCancelMock.expectedInvocationsOrigin, afterOrderCancelCounter)
	}
}

type mLomsServiseMockOrderCreate struct {
	optional           bool
	mock               *LomsServiseMock
	defaultExpectation *LomsServiseMockOrderCreateExpectation
	expectations       []*LomsServiseMockOrderCreateExpectation

	callArgs []*LomsServiseMockOrderCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiseMockOrderCreateExpectation specifies expectation struct of the LomsServise.OrderCreate
type LomsServiseMockOrderCreateExpectation struct {
	mock               *LomsServiseMock
	params             *LomsServiseMockOrderCreateParams
	paramPtrs          *LomsServiseMockOrderCreateParamPtrs
	expectationOrigins LomsServiseMockOrderCreateExpectationOrigins
	results            *LomsServiseMockOrderCreateResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiseMockOrderCreateParams contains parameters of the LomsServise.OrderCreate
type LomsServiseMockOrderCreateParams struct {
	ctx    context.Context
	userID int64
	items  []model.Item
}

// LomsServiseMockOrderCreateParamPtrs contains pointers to parameters of the LomsServise.OrderCreate
type LomsServiseMockOrderCreateParamPtrs struct {
	ctx    *context.Context
	userID *int64
	items  *[]model.Item
}

// LomsServiseMockOrderCreateResults contains results of the LomsServise.OrderCreate
type LomsServiseMockOrderCreateResults struct {
	i1  int64
	err error
}

// LomsServiseMockOrderCreateOrigins contains origins of expectations of the LomsServise.OrderCreate
type LomsServiseMockOrderCreateExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItems  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreate *mLomsServiseMockOrderCreate) Optional() *mLomsServiseMockOrderCreate {
	mmOrderCreate.optional = true
	return mmOrderCreate
}

// Expect sets up expected params for LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) Expect(ctx context.Context, userID int64, items []model.Item) *mLomsServiseMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiseMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.paramPtrs != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by ExpectParams functions")
	}

	mmOrderCreate.defaultExpectation.params = &LomsServiseMockOrderCreateParams{ctx, userID, items}
	mmOrderCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// ExpectCtxParam1 sets up expected param ctx for LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) ExpectCtxParam1(ctx context.Context) *mLomsServiseMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiseMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiseMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCreate
}

// ExpectUserIDParam2 sets up expected param userID for LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) ExpectUserIDParam2(userID int64) *mLomsServiseMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiseMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiseMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.userID = &userID
	mmOrderCreate.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmOrderCreate
}

// ExpectItemsParam3 sets up expected param items for LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) ExpectItemsParam3(items []model.Item) *mLomsServiseMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiseMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiseMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.items = &items
	mmOrderCreate.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) Inspect(f func(ctx context.Context, userID int64, items []model.Item)) *mLomsServiseMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for LomsServiseMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by LomsServise.OrderCreate
func (mmOrderCreate *mLomsServiseMockOrderCreate) Return(i1 int64, err error) *LomsServiseMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiseMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &LomsServiseMockOrderCreateResults{i1, err}
	mmOrderCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// Set uses given function f to mock the LomsServise.OrderCreate method
func (mmOrderCreate *mLomsServiseMockOrderCreate) Set(f func(ctx context.Context, userID int64, items []model.Item) (i1 int64, err error)) *LomsServiseMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the LomsServise.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the LomsServise.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	mmOrderCreate.mock.funcOrderCreateOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// When sets expectation for the LomsServise.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mLomsServiseMockOrderCreate) When(ctx context.Context, userID int64, items []model.Item) *LomsServiseMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiseMock.OrderCreate mock is already set by Set")
	}

	expectation := &LomsServiseMockOrderCreateExpectation{
		mock:               mmOrderCreate.mock,
		params:             &LomsServiseMockOrderCreateParams{ctx, userID, items},
		expectationOrigins: LomsServiseMockOrderCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up LomsServise.OrderCreate return parameters for the expectation previously defined by the When method
func (e *LomsServiseMockOrderCreateExpectation) Then(i1 int64, err error) *LomsServiseMock {
	e.results = &LomsServiseMockOrderCreateResults{i1, err}
	return e.mock
}

// Times sets number of times LomsServise.OrderCreate should be invoked
func (mmOrderCreate *mLomsServiseMockOrderCreate) Times(n uint64) *mLomsServiseMockOrderCreate {
	if n == 0 {
		mmOrderCreate.mock.t.Fatalf("Times of LomsServiseMock.OrderCreate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreate.expectedInvocations, n)
	mmOrderCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCreate
}

func (mmOrderCreate *mLomsServiseMockOrderCreate) invocationsDone() bool {
	if len(mmOrderCreate.expectations) == 0 && mmOrderCreate.defaultExpectation == nil && mmOrderCreate.mock.funcOrderCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreate.mock.afterOrderCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreate implements mm_server.LomsServise
func (mmOrderCreate *LomsServiseMock) OrderCreate(ctx context.Context, userID int64, items []model.Item) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	mmOrderCreate.t.Helper()

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, userID, items)
	}

	mm_params := LomsServiseMockOrderCreateParams{ctx, userID, items}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreate.OrderCreateMock.defaultExpectation.paramPtrs

		mm_got := LomsServiseMockOrderCreateParams{ctx, userID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreate.t.Errorf("LomsServiseMock.OrderCreate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmOrderCreate.t.Errorf("LomsServiseMock.OrderCreate got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmOrderCreate.t.Errorf("LomsServiseMock.OrderCreate got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("LomsServiseMock.OrderCreate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the LomsServiseMock.OrderCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, userID, items)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to LomsServiseMock.OrderCreate. %v %v %v", ctx, userID, items)
	return
}

// OrderCreateAfterCounter returns a count of finished LomsServiseMock.OrderCreate invocations
func (mmOrderCreate *LomsServiseMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of LomsServiseMock.OrderCreate invocations
func (mmOrderCreate *LomsServiseMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to LomsServiseMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mLomsServiseMockOrderCreate) Calls() []*LomsServiseMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*LomsServiseMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *LomsServiseMock) MinimockOrderCreateDone() bool {
	if m.OrderCreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateMock.invocationsDone()
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *LomsServiseMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCreate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCreateCounter := mm_atomic.LoadUint64(&m.afterOrderCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && afterOrderCreateCounter < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCreate at\n%s", m.OrderCreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiseMock.OrderCreate at\n%s with params: %#v", m.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && afterOrderCreateCounter < 1 {
		m.t.Errorf("Expected call to LomsServiseMock.OrderCreate at\n%s", m.funcOrderCreateOrigin)
	}

	if !m.OrderCreateMock.invocationsDone() && afterOrderCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiseMock.OrderCreate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateMock.expectedInvocations), m.OrderCreateMock.expectedInvocationsOrigin, afterOrderCreateCounter)
	}
}

type mLomsServiseMockOrderInfo struct {
	optional           bool
	mock               *LomsServiseMock
	defaultExpectation *LomsServiseMockOrderInfoExpectation
	expectations       []*LomsServiseMockOrderInfoExpectation

	callArgs []*LomsServiseMockOrderInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiseMockOrderInfoExpectation specifies expectation struct of the LomsServise.OrderInfo
type LomsServiseMockOrderInfoExpectation struct {
	mock               *LomsServiseMock
	params             *LomsServiseMockOrderInfoParams
	paramPtrs          *LomsServiseMockOrderInfoParamPtrs
	expectationOrigins LomsServiseMockOrderInfoExpectationOrigins
	results            *LomsServiseMockOrderInfoResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiseMockOrderInfoParams contains parameters of the LomsServise.OrderInfo
type LomsServiseMockOrderInfoParams struct {
	ctx     context.Context
	orderId int64
}

// LomsServiseMockOrderInfoParamPtrs contains pointers to parameters of the LomsServise.OrderInfo
type LomsServiseMockOrderInfoParamPtrs struct {
	ctx     *context.Context
	orderId *int64
}

// LomsServiseMockOrderInfoResults contains results of the LomsServise.OrderInfo
type LomsServiseMockOrderInfoResults struct {
	op1 *model.Order
	err error
}

// LomsServiseMockOrderInfoOrigins contains origins of expectations of the LomsServise.OrderInfo
type LomsServiseMockOrderInfoExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderInfo *mLomsServiseMockOrderInfo) Optional() *mLomsServiseMockOrderInfo {
	mmOrderInfo.optional = true
	return mmOrderInfo
}

// Expect sets up expected params for LomsServise.OrderInfo
func (mmOrderInfo *mLomsServiseMockOrderInfo) Expect(ctx context.Context, orderId int64) *mLomsServiseMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiseMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.paramPtrs != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by ExpectParams functions")
	}

	mmOrderInfo.defaultExpectation.params = &LomsServiseMockOrderInfoParams{ctx, orderId}
	mmOrderInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderInfo.expectations {
		if minimock.Equal(e.params, mmOrderInfo.defaultExpectation.params) {
			mmOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderInfo.defaultExpectation.params)
		}
	}

	return mmOrderInfo
}

// ExpectCtxParam1 sets up expected param ctx for LomsServise.OrderInfo
func (mmOrderInfo *mLomsServiseMockOrderInfo) ExpectCtxParam1(ctx context.Context) *mLomsServiseMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiseMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServiseMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderInfo
}

// ExpectOrderIdParam2 sets up expected param orderId for LomsServise.OrderInfo
func (mmOrderInfo *mLomsServiseMockOrderInfo) ExpectOrderIdParam2(orderId int64) *mLomsServiseMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiseMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServiseMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.orderId = &orderId
	mmOrderInfo.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the LomsServise.OrderInfo
func (mmOrderInfo *mLomsServiseMockOrderInfo) Inspect(f func(ctx context.Context, orderId int64)) *mLomsServiseMockOrderInfo {
	if mmOrderInfo.mock.inspectFuncOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("Inspect function is already set for LomsServiseMock.OrderInfo")
	}

	mmOrderInfo.mock.inspectFuncOrderInfo = f

	return mmOrderInfo
}

// Return sets up results that will be returned by LomsServise.OrderInfo
func (mmOrderInfo *mLomsServiseMockOrderInfo) Return(op1 *model.Order, err error) *LomsServiseMock {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiseMockOrderInfoExpectation{mock: mmOrderInfo.mock}
	}
	mmOrderInfo.defaultExpectation.results = &LomsServiseMockOrderInfoResults{op1, err}
	mmOrderInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderInfo.mock
}

// Set uses given function f to mock the LomsServise.OrderInfo method
func (mmOrderInfo *mLomsServiseMockOrderInfo) Set(f func(ctx context.Context, orderId int64) (op1 *model.Order, err error)) *LomsServiseMock {
	if mmOrderInfo.defaultExpectation != nil {
		mmOrderInfo.mock.t.Fatalf("Default expectation is already set for the LomsServise.OrderInfo method")
	}

	if len(mmOrderInfo.expectations) > 0 {
		mmOrderInfo.mock.t.Fatalf("Some expectations are already set for the LomsServise.OrderInfo method")
	}

	mmOrderInfo.mock.funcOrderInfo = f
	mmOrderInfo.mock.funcOrderInfoOrigin = minimock.CallerInfo(1)
	return mmOrderInfo.mock
}

// When sets expectation for the LomsServise.OrderInfo which will trigger the result defined by the following
// Then helper
func (mmOrderInfo *mLomsServiseMockOrderInfo) When(ctx context.Context, orderId int64) *LomsServiseMockOrderInfoExpectation {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiseMock.OrderInfo mock is already set by Set")
	}

	expectation := &LomsServiseMockOrderInfoExpectation{
		mock:               mmOrderInfo.mock,
		params:             &LomsServiseMockOrderInfoParams{ctx, orderId},
		expectationOrigins: LomsServiseMockOrderInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderInfo.expectations = append(mmOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up LomsServise.OrderInfo return parameters for the expectation previously defined by the When method
func (e *LomsServiseMockOrderInfoExpectation) Then(op1 *model.Order, err error) *LomsServiseMock {
	e.results = &LomsServiseMockOrderInfoResults{op1, err}
	return e.mock
}

// Times sets number of times LomsServise.OrderInfo should be invoked
func (mmOrderInfo *mLomsServiseMockOrderInfo) Times(n uint64) *mLomsServiseMockOrderInfo {
	if n == 0 {
		mmOrderInfo.mock.t.Fatalf("Times of LomsServiseMock.OrderInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderInfo.expectedInvocations, n)
	mmOrderInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderInfo
}

func (mmOrderInfo *mLomsServiseMockOrderInfo) invocationsDone() bool {
	if len(mmOrderInfo.expectations) == 0 && mmOrderInfo.defaultExpectation == nil && mmOrderInfo.mock.funcOrderInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderInfo.mock.afterOrderInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderInfo implements mm_server.LomsServise
func (mmOrderInfo *LomsServiseMock) OrderInfo(ctx context.Context, orderId int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmOrderInfo.beforeOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderInfo.afterOrderInfoCounter, 1)

	mmOrderInfo.t.Helper()

	if mmOrderInfo.inspectFuncOrderInfo != nil {
		mmOrderInfo.inspectFuncOrderInfo(ctx, orderId)
	}

	mm_params := LomsServiseMockOrderInfoParams{ctx, orderId}

	// Record call args
	mmOrderInfo.OrderInfoMock.mutex.Lock()
	mmOrderInfo.OrderInfoMock.callArgs = append(mmOrderInfo.OrderInfoMock.callArgs, &mm_params)
	mmOrderInfo.OrderInfoMock.mutex.Unlock()

	for _, e := range mmOrderInfo.OrderInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderInfo.OrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderInfo.OrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderInfo.OrderInfoMock.defaultExpectation.params
		mm_want_ptrs := mmOrderInfo.OrderInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServiseMockOrderInfoParams{ctx, orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderInfo.t.Errorf("LomsServiseMock.OrderInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmOrderInfo.t.Errorf("LomsServiseMock.OrderInfo got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderInfo.t.Errorf("LomsServiseMock.OrderInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderInfo.OrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderInfo.t.Fatal("No results are set for the LomsServiseMock.OrderInfo")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderInfo.funcOrderInfo != nil {
		return mmOrderInfo.funcOrderInfo(ctx, orderId)
	}
	mmOrderInfo.t.Fatalf("Unexpected call to LomsServiseMock.OrderInfo. %v %v", ctx, orderId)
	return
}

// OrderInfoAfterCounter returns a count of finished LomsServiseMock.OrderInfo invocations
func (mmOrderInfo *LomsServiseMock) OrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.afterOrderInfoCounter)
}

// OrderInfoBeforeCounter returns a count of LomsServiseMock.OrderInfo invocations
func (mmOrderInfo *LomsServiseMock) OrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.beforeOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServiseMock.OrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderInfo *mLomsServiseMockOrderInfo) Calls() []*LomsServiseMockOrderInfoParams {
	mmOrderInfo.mutex.RLock()

	argCopy := make([]*LomsServiseMockOrderInfoParams, len(mmOrderInfo.callArgs))
	copy(argCopy, mmOrderInfo.callArgs)

	mmOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderInfoDone returns true if the count of the OrderInfo invocations corresponds
// the number of defined expectations
func (m *LomsServiseMock) MinimockOrderInfoDone() bool {
	if m.OrderInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderInfoMock.invocationsDone()
}

// MinimockOrderInfoInspect logs each unmet expectation
func (m *LomsServiseMock) MinimockOrderInfoInspect() {
	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiseMock.OrderInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderInfoCounter := mm_atomic.LoadUint64(&m.afterOrderInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoMock.defaultExpectation != nil && afterOrderInfoCounter < 1 {
		if m.OrderInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiseMock.OrderInfo at\n%s", m.OrderInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiseMock.OrderInfo at\n%s with params: %#v", m.OrderInfoMock.defaultExpectation.expectationOrigins.origin, *m.OrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfo != nil && afterOrderInfoCounter < 1 {
		m.t.Errorf("Expected call to LomsServiseMock.OrderInfo at\n%s", m.funcOrderInfoOrigin)
	}

	if !m.OrderInfoMock.invocationsDone() && afterOrderInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiseMock.OrderInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderInfoMock.expectedInvocations), m.OrderInfoMock.expectedInvocationsOrigin, afterOrderInfoCounter)
	}
}

type mLomsServiseMockOrderPay struct {
	optional           bool
	mock               *LomsServiseMock
	defaultExpectation *LomsServiseMockOrderPayExpectation
	expectations       []*LomsServiseMockOrderPayExpectation

	callArgs []*LomsServiseMockOrderPayParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiseMockOrderPayExpectation specifies expectation struct of the LomsServise.OrderPay
type LomsServiseMockOrderPayExpectation struct {
	mock               *LomsServiseMock
	params             *LomsServiseMockOrderPayParams
	paramPtrs          *LomsServiseMockOrderPayParamPtrs
	expectationOrigins LomsServiseMockOrderPayExpectationOrigins
	results            *LomsServiseMockOrderPayResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiseMockOrderPayParams contains parameters of the LomsServise.OrderPay
type LomsServiseMockOrderPayParams struct {
	ctx     context.Context
	orderId int64
}

// LomsServiseMockOrderPayParamPtrs contains pointers to parameters of the LomsServise.OrderPay
type LomsServiseMockOrderPayParamPtrs struct {
	ctx     *context.Context
	orderId *int64
}

// LomsServiseMockOrderPayResults contains results of the LomsServise.OrderPay
type LomsServiseMockOrderPayResults struct {
	err error
}

// LomsServiseMockOrderPayOrigins contains origins of expectations of the LomsServise.OrderPay
type LomsServiseMockOrderPayExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderPay *mLomsServiseMockOrderPay) Optional() *mLomsServiseMockOrderPay {
	mmOrderPay.optional = true
	return mmOrderPay
}

// Expect sets up expected params for LomsServise.OrderPay
func (mmOrderPay *mLomsServiseMockOrderPay) Expect(ctx context.Context, orderId int64) *mLomsServiseMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiseMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.paramPtrs != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by ExpectParams functions")
	}

	mmOrderPay.defaultExpectation.params = &LomsServiseMockOrderPayParams{ctx, orderId}
	mmOrderPay.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// ExpectCtxParam1 sets up expected param ctx for LomsServise.OrderPay
func (mmOrderPay *mLomsServiseMockOrderPay) ExpectCtxParam1(ctx context.Context) *mLomsServiseMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiseMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServiseMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderPay.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderPay
}

// ExpectOrderIdParam2 sets up expected param orderId for LomsServise.OrderPay
func (mmOrderPay *mLomsServiseMockOrderPay) ExpectOrderIdParam2(orderId int64) *mLomsServiseMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiseMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServiseMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.orderId = &orderId
	mmOrderPay.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the LomsServise.OrderPay
func (mmOrderPay *mLomsServiseMockOrderPay) Inspect(f func(ctx context.Context, orderId int64)) *mLomsServiseMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for LomsServiseMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by LomsServise.OrderPay
func (mmOrderPay *mLomsServiseMockOrderPay) Return(err error) *LomsServiseMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiseMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &LomsServiseMockOrderPayResults{err}
	mmOrderPay.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderPay.mock
}

// Set uses given function f to mock the LomsServise.OrderPay method
func (mmOrderPay *mLomsServiseMockOrderPay) Set(f func(ctx context.Context, orderId int64) (err error)) *LomsServiseMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the LomsServise.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the LomsServise.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	mmOrderPay.mock.funcOrderPayOrigin = minimock.CallerInfo(1)
	return mmOrderPay.mock
}

// When sets expectation for the LomsServise.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mLomsServiseMockOrderPay) When(ctx context.Context, orderId int64) *LomsServiseMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiseMock.OrderPay mock is already set by Set")
	}

	expectation := &LomsServiseMockOrderPayExpectation{
		mock:               mmOrderPay.mock,
		params:             &LomsServiseMockOrderPayParams{ctx, orderId},
		expectationOrigins: LomsServiseMockOrderPayExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up LomsServise.OrderPay return parameters for the expectation previously defined by the When method
func (e *LomsServiseMockOrderPayExpectation) Then(err error) *LomsServiseMock {
	e.results = &LomsServiseMockOrderPayResults{err}
	return e.mock
}

// Times sets number of times LomsServise.OrderPay should be invoked
func (mmOrderPay *mLomsServiseMockOrderPay) Times(n uint64) *mLomsServiseMockOrderPay {
	if n == 0 {
		mmOrderPay.mock.t.Fatalf("Times of LomsServiseMock.OrderPay mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderPay.expectedInvocations, n)
	mmOrderPay.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderPay
}

func (mmOrderPay *mLomsServiseMockOrderPay) invocationsDone() bool {
	if len(mmOrderPay.expectations) == 0 && mmOrderPay.defaultExpectation == nil && mmOrderPay.mock.funcOrderPay == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderPay.mock.afterOrderPayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderPay.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderPay implements mm_server.LomsServise
func (mmOrderPay *LomsServiseMock) OrderPay(ctx context.Context, orderId int64) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	mmOrderPay.t.Helper()

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, orderId)
	}

	mm_params := LomsServiseMockOrderPayParams{ctx, orderId}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_want_ptrs := mmOrderPay.OrderPayMock.defaultExpectation.paramPtrs

		mm_got := LomsServiseMockOrderPayParams{ctx, orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderPay.t.Errorf("LomsServiseMock.OrderPay got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmOrderPay.t.Errorf("LomsServiseMock.OrderPay got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("LomsServiseMock.OrderPay got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the LomsServiseMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, orderId)
	}
	mmOrderPay.t.Fatalf("Unexpected call to LomsServiseMock.OrderPay. %v %v", ctx, orderId)
	return
}

// OrderPayAfterCounter returns a count of finished LomsServiseMock.OrderPay invocations
func (mmOrderPay *LomsServiseMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of LomsServiseMock.OrderPay invocations
func (mmOrderPay *LomsServiseMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to LomsServiseMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mLomsServiseMockOrderPay) Calls() []*LomsServiseMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*LomsServiseMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *LomsServiseMock) MinimockOrderPayDone() bool {
	if m.OrderPayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderPayMock.invocationsDone()
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *LomsServiseMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiseMock.OrderPay at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderPayCounter := mm_atomic.LoadUint64(&m.afterOrderPayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && afterOrderPayCounter < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiseMock.OrderPay at\n%s", m.OrderPayMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiseMock.OrderPay at\n%s with params: %#v", m.OrderPayMock.defaultExpectation.expectationOrigins.origin, *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && afterOrderPayCounter < 1 {
		m.t.Errorf("Expected call to LomsServiseMock.OrderPay at\n%s", m.funcOrderPayOrigin)
	}

	if !m.OrderPayMock.invocationsDone() && afterOrderPayCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiseMock.OrderPay at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderPayMock.expectedInvocations), m.OrderPayMock.expectedInvocationsOrigin, afterOrderPayCounter)
	}
}

type mLomsServiseMockStocksInfo struct {
	optional           bool
	mock               *LomsServiseMock
	defaultExpectation *LomsServiseMockStocksInfoExpectation
	expectations       []*LomsServiseMockStocksInfoExpectation

	callArgs []*LomsServiseMockStocksInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiseMockStocksInfoExpectation specifies expectation struct of the LomsServise.StocksInfo
type LomsServiseMockStocksInfoExpectation struct {
	mock               *LomsServiseMock
	params             *LomsServiseMockStocksInfoParams
	paramPtrs          *LomsServiseMockStocksInfoParamPtrs
	expectationOrigins LomsServiseMockStocksInfoExpectationOrigins
	results            *LomsServiseMockStocksInfoResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiseMockStocksInfoParams contains parameters of the LomsServise.StocksInfo
type LomsServiseMockStocksInfoParams struct {
	ctx context.Context
	sku int64
}

// LomsServiseMockStocksInfoParamPtrs contains pointers to parameters of the LomsServise.StocksInfo
type LomsServiseMockStocksInfoParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// LomsServiseMockStocksInfoResults contains results of the LomsServise.StocksInfo
type LomsServiseMockStocksInfoResults struct {
	u1  uint32
	err error
}

// LomsServiseMockStocksInfoOrigins contains origins of expectations of the LomsServise.StocksInfo
type LomsServiseMockStocksInfoExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksInfo *mLomsServiseMockStocksInfo) Optional() *mLomsServiseMockStocksInfo {
	mmStocksInfo.optional = true
	return mmStocksInfo
}

// Expect sets up expected params for LomsServise.StocksInfo
func (mmStocksInfo *mLomsServiseMockStocksInfo) Expect(ctx context.Context, sku int64) *mLomsServiseMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiseMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.paramPtrs != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by ExpectParams functions")
	}

	mmStocksInfo.defaultExpectation.params = &LomsServiseMockStocksInfoParams{ctx, sku}
	mmStocksInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStocksInfo.expectations {
		if minimock.Equal(e.params, mmStocksInfo.defaultExpectation.params) {
			mmStocksInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksInfo.defaultExpectation.params)
		}
	}

	return mmStocksInfo
}

// ExpectCtxParam1 sets up expected param ctx for LomsServise.StocksInfo
func (mmStocksInfo *mLomsServiseMockStocksInfo) ExpectCtxParam1(ctx context.Context) *mLomsServiseMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiseMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServiseMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmStocksInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStocksInfo
}

// ExpectSkuParam2 sets up expected param sku for LomsServise.StocksInfo
func (mmStocksInfo *mLomsServiseMockStocksInfo) ExpectSkuParam2(sku int64) *mLomsServiseMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiseMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServiseMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.sku = &sku
	mmStocksInfo.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmStocksInfo
}

// Inspect accepts an inspector function that has same arguments as the LomsServise.StocksInfo
func (mmStocksInfo *mLomsServiseMockStocksInfo) Inspect(f func(ctx context.Context, sku int64)) *mLomsServiseMockStocksInfo {
	if mmStocksInfo.mock.inspectFuncStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("Inspect function is already set for LomsServiseMock.StocksInfo")
	}

	mmStocksInfo.mock.inspectFuncStocksInfo = f

	return mmStocksInfo
}

// Return sets up results that will be returned by LomsServise.StocksInfo
func (mmStocksInfo *mLomsServiseMockStocksInfo) Return(u1 uint32, err error) *LomsServiseMock {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiseMockStocksInfoExpectation{mock: mmStocksInfo.mock}
	}
	mmStocksInfo.defaultExpectation.results = &LomsServiseMockStocksInfoResults{u1, err}
	mmStocksInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStocksInfo.mock
}

// Set uses given function f to mock the LomsServise.StocksInfo method
func (mmStocksInfo *mLomsServiseMockStocksInfo) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *LomsServiseMock {
	if mmStocksInfo.defaultExpectation != nil {
		mmStocksInfo.mock.t.Fatalf("Default expectation is already set for the LomsServise.StocksInfo method")
	}

	if len(mmStocksInfo.expectations) > 0 {
		mmStocksInfo.mock.t.Fatalf("Some expectations are already set for the LomsServise.StocksInfo method")
	}

	mmStocksInfo.mock.funcStocksInfo = f
	mmStocksInfo.mock.funcStocksInfoOrigin = minimock.CallerInfo(1)
	return mmStocksInfo.mock
}

// When sets expectation for the LomsServise.StocksInfo which will trigger the result defined by the following
// Then helper
func (mmStocksInfo *mLomsServiseMockStocksInfo) When(ctx context.Context, sku int64) *LomsServiseMockStocksInfoExpectation {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiseMock.StocksInfo mock is already set by Set")
	}

	expectation := &LomsServiseMockStocksInfoExpectation{
		mock:               mmStocksInfo.mock,
		params:             &LomsServiseMockStocksInfoParams{ctx, sku},
		expectationOrigins: LomsServiseMockStocksInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStocksInfo.expectations = append(mmStocksInfo.expectations, expectation)
	return expectation
}

// Then sets up LomsServise.StocksInfo return parameters for the expectation previously defined by the When method
func (e *LomsServiseMockStocksInfoExpectation) Then(u1 uint32, err error) *LomsServiseMock {
	e.results = &LomsServiseMockStocksInfoResults{u1, err}
	return e.mock
}

// Times sets number of times LomsServise.StocksInfo should be invoked
func (mmStocksInfo *mLomsServiseMockStocksInfo) Times(n uint64) *mLomsServiseMockStocksInfo {
	if n == 0 {
		mmStocksInfo.mock.t.Fatalf("Times of LomsServiseMock.StocksInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksInfo.expectedInvocations, n)
	mmStocksInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStocksInfo
}

func (mmStocksInfo *mLomsServiseMockStocksInfo) invocationsDone() bool {
	if len(mmStocksInfo.expectations) == 0 && mmStocksInfo.defaultExpectation == nil && mmStocksInfo.mock.funcStocksInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksInfo.mock.afterStocksInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksInfo implements mm_server.LomsServise
func (mmStocksInfo *LomsServiseMock) StocksInfo(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmStocksInfo.beforeStocksInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksInfo.afterStocksInfoCounter, 1)

	mmStocksInfo.t.Helper()

	if mmStocksInfo.inspectFuncStocksInfo != nil {
		mmStocksInfo.inspectFuncStocksInfo(ctx, sku)
	}

	mm_params := LomsServiseMockStocksInfoParams{ctx, sku}

	// Record call args
	mmStocksInfo.StocksInfoMock.mutex.Lock()
	mmStocksInfo.StocksInfoMock.callArgs = append(mmStocksInfo.StocksInfoMock.callArgs, &mm_params)
	mmStocksInfo.StocksInfoMock.mutex.Unlock()

	for _, e := range mmStocksInfo.StocksInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmStocksInfo.StocksInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksInfo.StocksInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksInfo.StocksInfoMock.defaultExpectation.params
		mm_want_ptrs := mmStocksInfo.StocksInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServiseMockStocksInfoParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksInfo.t.Errorf("LomsServiseMock.StocksInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksInfo.t.Errorf("LomsServiseMock.StocksInfo got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksInfo.t.Errorf("LomsServiseMock.StocksInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStocksInfo.StocksInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksInfo.StocksInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksInfo.t.Fatal("No results are set for the LomsServiseMock.StocksInfo")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmStocksInfo.funcStocksInfo != nil {
		return mmStocksInfo.funcStocksInfo(ctx, sku)
	}
	mmStocksInfo.t.Fatalf("Unexpected call to LomsServiseMock.StocksInfo. %v %v", ctx, sku)
	return
}

// StocksInfoAfterCounter returns a count of finished LomsServiseMock.StocksInfo invocations
func (mmStocksInfo *LomsServiseMock) StocksInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.afterStocksInfoCounter)
}

// StocksInfoBeforeCounter returns a count of LomsServiseMock.StocksInfo invocations
func (mmStocksInfo *LomsServiseMock) StocksInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.beforeStocksInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServiseMock.StocksInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksInfo *mLomsServiseMockStocksInfo) Calls() []*LomsServiseMockStocksInfoParams {
	mmStocksInfo.mutex.RLock()

	argCopy := make([]*LomsServiseMockStocksInfoParams, len(mmStocksInfo.callArgs))
	copy(argCopy, mmStocksInfo.callArgs)

	mmStocksInfo.mutex.RUnlock()

	return argCopy
}

// MinimockStocksInfoDone returns true if the count of the StocksInfo invocations corresponds
// the number of defined expectations
func (m *LomsServiseMock) MinimockStocksInfoDone() bool {
	if m.StocksInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksInfoMock.invocationsDone()
}

// MinimockStocksInfoInspect logs each unmet expectation
func (m *LomsServiseMock) MinimockStocksInfoInspect() {
	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiseMock.StocksInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStocksInfoCounter := mm_atomic.LoadUint64(&m.afterStocksInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksInfoMock.defaultExpectation != nil && afterStocksInfoCounter < 1 {
		if m.StocksInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiseMock.StocksInfo at\n%s", m.StocksInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiseMock.StocksInfo at\n%s with params: %#v", m.StocksInfoMock.defaultExpectation.expectationOrigins.origin, *m.StocksInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksInfo != nil && afterStocksInfoCounter < 1 {
		m.t.Errorf("Expected call to LomsServiseMock.StocksInfo at\n%s", m.funcStocksInfoOrigin)
	}

	if !m.StocksInfoMock.invocationsDone() && afterStocksInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiseMock.StocksInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StocksInfoMock.expectedInvocations), m.StocksInfoMock.expectedInvocationsOrigin, afterStocksInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsServiseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCancelInspect()

			m.MinimockOrderCreateInspect()

			m.MinimockOrderInfoInspect()

			m.MinimockOrderPayInspect()

			m.MinimockStocksInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsServiseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsServiseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCancelDone() &&
		m.MinimockOrderCreateDone() &&
		m.MinimockOrderInfoDone() &&
		m.MinimockOrderPayDone() &&
		m.MinimockStocksInfoDone()
}
