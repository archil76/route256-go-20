// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/domain/service/outbox.OutboxRepository -o outbox_repository_mock.go -n OutboxRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OutboxRepositoryMock implements mm_outbox.OutboxRepository
type OutboxRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, key string, status string, payload []byte) (i1 int, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, key string, status string, payload []byte)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOutboxRepositoryMockCreate

	funcGet          func(ctx context.Context) (oap1 *[]model.OutboxItem, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mOutboxRepositoryMockGet

	funcSetStatus          func(ctx context.Context, id int, status string) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, id int, status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOutboxRepositoryMockSetStatus
}

// NewOutboxRepositoryMock returns a mock for mm_outbox.OutboxRepository
func NewOutboxRepositoryMock(t minimock.Tester) *OutboxRepositoryMock {
	m := &OutboxRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOutboxRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OutboxRepositoryMockCreateParams{}

	m.GetMock = mOutboxRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*OutboxRepositoryMockGetParams{}

	m.SetStatusMock = mOutboxRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OutboxRepositoryMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOutboxRepositoryMockCreate struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockCreateExpectation
	expectations       []*OutboxRepositoryMockCreateExpectation

	callArgs []*OutboxRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockCreateExpectation specifies expectation struct of the OutboxRepository.Create
type OutboxRepositoryMockCreateExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockCreateParams
	paramPtrs          *OutboxRepositoryMockCreateParamPtrs
	expectationOrigins OutboxRepositoryMockCreateExpectationOrigins
	results            *OutboxRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockCreateParams contains parameters of the OutboxRepository.Create
type OutboxRepositoryMockCreateParams struct {
	ctx     context.Context
	key     string
	status  string
	payload []byte
}

// OutboxRepositoryMockCreateParamPtrs contains pointers to parameters of the OutboxRepository.Create
type OutboxRepositoryMockCreateParamPtrs struct {
	ctx     *context.Context
	key     *string
	status  *string
	payload *[]byte
}

// OutboxRepositoryMockCreateResults contains results of the OutboxRepository.Create
type OutboxRepositoryMockCreateResults struct {
	i1  int
	err error
}

// OutboxRepositoryMockCreateOrigins contains origins of expectations of the OutboxRepository.Create
type OutboxRepositoryMockCreateExpectationOrigins struct {
	origin        string
	originCtx     string
	originKey     string
	originStatus  string
	originPayload string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOutboxRepositoryMockCreate) Optional() *mOutboxRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Expect(ctx context.Context, key string, status string, payload []byte) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OutboxRepositoryMockCreateParams{ctx, key, status, payload}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectKeyParam2 sets up expected param key for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectKeyParam2(key string) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.key = &key
	mmCreate.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectStatusParam3 sets up expected param status for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectStatusParam3(status string) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.status = &status
	mmCreate.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPayloadParam4 sets up expected param payload for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectPayloadParam4(payload []byte) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.payload = &payload
	mmCreate.defaultExpectation.expectationOrigins.originPayload = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Inspect(f func(ctx context.Context, key string, status string, payload []byte)) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Return(i1 int, err error) *OutboxRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OutboxRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OutboxRepository.Create method
func (mmCreate *mOutboxRepositoryMockCreate) Set(f func(ctx context.Context, key string, status string, payload []byte) (i1 int, err error)) *OutboxRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OutboxRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOutboxRepositoryMockCreate) When(ctx context.Context, key string, status string, payload []byte) *OutboxRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OutboxRepositoryMockCreateParams{ctx, key, status, payload},
		expectationOrigins: OutboxRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.Create return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockCreateExpectation) Then(i1 int, err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times OutboxRepository.Create should be invoked
func (mmCreate *mOutboxRepositoryMockCreate) Times(n uint64) *mOutboxRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OutboxRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOutboxRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_outbox.OutboxRepository
func (mmCreate *OutboxRepositoryMock) Create(ctx context.Context, key string, status string, payload []byte) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, key, status, payload)
	}

	mm_params := OutboxRepositoryMockCreateParams{ctx, key, status, payload}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockCreateParams{ctx, key, status, payload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter payload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPayload, *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OutboxRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, key, status, payload)
	}
	mmCreate.t.Fatalf("Unexpected call to OutboxRepositoryMock.Create. %v %v %v %v", ctx, key, status, payload)
	return
}

// CreateAfterCounter returns a count of finished OutboxRepositoryMock.Create invocations
func (mmCreate *OutboxRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OutboxRepositoryMock.Create invocations
func (mmCreate *OutboxRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOutboxRepositoryMockCreate) Calls() []*OutboxRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOutboxRepositoryMockGet struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockGetExpectation
	expectations       []*OutboxRepositoryMockGetExpectation

	callArgs []*OutboxRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockGetExpectation specifies expectation struct of the OutboxRepository.Get
type OutboxRepositoryMockGetExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockGetParams
	paramPtrs          *OutboxRepositoryMockGetParamPtrs
	expectationOrigins OutboxRepositoryMockGetExpectationOrigins
	results            *OutboxRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockGetParams contains parameters of the OutboxRepository.Get
type OutboxRepositoryMockGetParams struct {
	ctx context.Context
}

// OutboxRepositoryMockGetParamPtrs contains pointers to parameters of the OutboxRepository.Get
type OutboxRepositoryMockGetParamPtrs struct {
	ctx *context.Context
}

// OutboxRepositoryMockGetResults contains results of the OutboxRepository.Get
type OutboxRepositoryMockGetResults struct {
	oap1 *[]model.OutboxItem
	err  error
}

// OutboxRepositoryMockGetOrigins contains origins of expectations of the OutboxRepository.Get
type OutboxRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mOutboxRepositoryMockGet) Optional() *mOutboxRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for OutboxRepository.Get
func (mmGet *mOutboxRepositoryMockGet) Expect(ctx context.Context) *mOutboxRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutboxRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &OutboxRepositoryMockGetParams{ctx}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.Get
func (mmGet *mOutboxRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutboxRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OutboxRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.Get
func (mmGet *mOutboxRepositoryMockGet) Inspect(f func(ctx context.Context)) *mOutboxRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by OutboxRepository.Get
func (mmGet *mOutboxRepositoryMockGet) Return(oap1 *[]model.OutboxItem, err error) *OutboxRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OutboxRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &OutboxRepositoryMockGetResults{oap1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the OutboxRepository.Get method
func (mmGet *mOutboxRepositoryMockGet) Set(f func(ctx context.Context) (oap1 *[]model.OutboxItem, err error)) *OutboxRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the OutboxRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mOutboxRepositoryMockGet) When(ctx context.Context) *OutboxRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OutboxRepositoryMock.Get mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &OutboxRepositoryMockGetParams{ctx},
		expectationOrigins: OutboxRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.Get return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockGetExpectation) Then(oap1 *[]model.OutboxItem, err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockGetResults{oap1, err}
	return e.mock
}

// Times sets number of times OutboxRepository.Get should be invoked
func (mmGet *mOutboxRepositoryMockGet) Times(n uint64) *mOutboxRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of OutboxRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mOutboxRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_outbox.OutboxRepository
func (mmGet *OutboxRepositoryMock) Get(ctx context.Context) (oap1 *[]model.OutboxItem, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx)
	}

	mm_params := OutboxRepositoryMockGetParams{ctx}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oap1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockGetParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("OutboxRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("OutboxRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the OutboxRepositoryMock.Get")
		}
		return (*mm_results).oap1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx)
	}
	mmGet.t.Fatalf("Unexpected call to OutboxRepositoryMock.Get. %v", ctx)
	return
}

// GetAfterCounter returns a count of finished OutboxRepositoryMock.Get invocations
func (mmGet *OutboxRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of OutboxRepositoryMock.Get invocations
func (mmGet *OutboxRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mOutboxRepositoryMockGet) Calls() []*OutboxRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mOutboxRepositoryMockSetStatus struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockSetStatusExpectation
	expectations       []*OutboxRepositoryMockSetStatusExpectation

	callArgs []*OutboxRepositoryMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockSetStatusExpectation specifies expectation struct of the OutboxRepository.SetStatus
type OutboxRepositoryMockSetStatusExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockSetStatusParams
	paramPtrs          *OutboxRepositoryMockSetStatusParamPtrs
	expectationOrigins OutboxRepositoryMockSetStatusExpectationOrigins
	results            *OutboxRepositoryMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockSetStatusParams contains parameters of the OutboxRepository.SetStatus
type OutboxRepositoryMockSetStatusParams struct {
	ctx    context.Context
	id     int
	status string
}

// OutboxRepositoryMockSetStatusParamPtrs contains pointers to parameters of the OutboxRepository.SetStatus
type OutboxRepositoryMockSetStatusParamPtrs struct {
	ctx    *context.Context
	id     *int
	status *string
}

// OutboxRepositoryMockSetStatusResults contains results of the OutboxRepository.SetStatus
type OutboxRepositoryMockSetStatusResults struct {
	err error
}

// OutboxRepositoryMockSetStatusOrigins contains origins of expectations of the OutboxRepository.SetStatus
type OutboxRepositoryMockSetStatusExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Optional() *mOutboxRepositoryMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Expect(ctx context.Context, id int, status string) *mOutboxRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OutboxRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OutboxRepositoryMockSetStatusParams{ctx, id, status}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OutboxRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectIdParam2 sets up expected param id for OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) ExpectIdParam2(id int) *mOutboxRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OutboxRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.id = &id
	mmSetStatus.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) ExpectStatusParam3(status string) *mOutboxRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OutboxRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status
	mmSetStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Inspect(f func(ctx context.Context, id int, status string)) *mOutboxRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OutboxRepository.SetStatus
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Return(err error) *OutboxRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OutboxRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OutboxRepositoryMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the OutboxRepository.SetStatus method
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Set(f func(ctx context.Context, id int, status string) (err error)) *OutboxRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the OutboxRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOutboxRepositoryMockSetStatus) When(ctx context.Context, id int, status string) *OutboxRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OutboxRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &OutboxRepositoryMockSetStatusParams{ctx, id, status},
		expectationOrigins: OutboxRepositoryMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockSetStatusExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.SetStatus should be invoked
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Times(n uint64) *mOutboxRepositoryMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OutboxRepositoryMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mOutboxRepositoryMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_outbox.OutboxRepository
func (mmSetStatus *OutboxRepositoryMock) SetStatus(ctx context.Context, id int, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, id, status)
	}

	mm_params := OutboxRepositoryMockSetStatusParams{ctx, id, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockSetStatusParams{ctx, id, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OutboxRepositoryMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSetStatus.t.Errorf("OutboxRepositoryMock.SetStatus got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OutboxRepositoryMock.SetStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OutboxRepositoryMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OutboxRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, id, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OutboxRepositoryMock.SetStatus. %v %v %v", ctx, id, status)
	return
}

// SetStatusAfterCounter returns a count of finished OutboxRepositoryMock.SetStatus invocations
func (mmSetStatus *OutboxRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OutboxRepositoryMock.SetStatus invocations
func (mmSetStatus *OutboxRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOutboxRepositoryMockSetStatus) Calls() []*OutboxRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutboxRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutboxRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutboxRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetStatusDone()
}
