// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/domain/service.StockRepository -o stock_repository_mock.go -n StockRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements mm_service.StockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcGetBySKUOrigin    string
	inspectFuncGetBySKU   func(ctx context.Context, sku int64)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mStockRepositoryMockGetBySKU

	funcGetStock          func(ctx context.Context, sku int64) (sp1 *model.Stock, err error)
	funcGetStockOrigin    string
	inspectFuncGetStock   func(ctx context.Context, sku int64)
	afterGetStockCounter  uint64
	beforeGetStockCounter uint64
	GetStockMock          mStockRepositoryMockGetStock

	funcReserve          func(ctx context.Context, items []model.Item) (sa1 []model.Stock, err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, items []model.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockRepositoryMockReserve

	funcReserveCancel          func(ctx context.Context, items []model.Item) (err error)
	funcReserveCancelOrigin    string
	inspectFuncReserveCancel   func(ctx context.Context, items []model.Item)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStockRepositoryMockReserveCancel

	funcReserveRemove          func(ctx context.Context, items []model.Item) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, items []model.Item)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockRepositoryMockReserveRemove

	funcUpdateStock          func(ctx context.Context, stock model.Stock) (sp1 *model.Stock, err error)
	funcUpdateStockOrigin    string
	inspectFuncUpdateStock   func(ctx context.Context, stock model.Stock)
	afterUpdateStockCounter  uint64
	beforeUpdateStockCounter uint64
	UpdateStockMock          mStockRepositoryMockUpdateStock
}

// NewStockRepositoryMock returns a mock for mm_service.StockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mStockRepositoryMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*StockRepositoryMockGetBySKUParams{}

	m.GetStockMock = mStockRepositoryMockGetStock{mock: m}
	m.GetStockMock.callArgs = []*StockRepositoryMockGetStockParams{}

	m.ReserveMock = mStockRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockRepositoryMockReserveParams{}

	m.ReserveCancelMock = mStockRepositoryMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StockRepositoryMockReserveCancelParams{}

	m.ReserveRemoveMock = mStockRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockRepositoryMockReserveRemoveParams{}

	m.UpdateStockMock = mStockRepositoryMockUpdateStock{mock: m}
	m.UpdateStockMock.callArgs = []*StockRepositoryMockUpdateStockParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetBySKU struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetBySKUExpectation
	expectations       []*StockRepositoryMockGetBySKUExpectation

	callArgs []*StockRepositoryMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetBySKUExpectation specifies expectation struct of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetBySKUParams
	paramPtrs          *StockRepositoryMockGetBySKUParamPtrs
	expectationOrigins StockRepositoryMockGetBySKUExpectationOrigins
	results            *StockRepositoryMockGetBySKUResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetBySKUParams contains parameters of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUParams struct {
	ctx context.Context
	sku int64
}

// StockRepositoryMockGetBySKUParamPtrs contains pointers to parameters of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// StockRepositoryMockGetBySKUResults contains results of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUResults struct {
	u1  uint32
	err error
}

// StockRepositoryMockGetBySKUOrigins contains origins of expectations of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Optional() *mStockRepositoryMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Expect(ctx context.Context, sku int64) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &StockRepositoryMockGetBySKUParams{ctx, sku}
	mmGetBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) ExpectSkuParam2(sku int64) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Inspect(f func(ctx context.Context, sku int64)) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Return(u1 uint32, err error) *StockRepositoryMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &StockRepositoryMockGetBySKUResults{u1, err}
	mmGetBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// Set uses given function f to mock the StockRepository.GetBySKU method
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *StockRepositoryMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	mmGetBySKU.mock.funcGetBySKUOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// When sets expectation for the StockRepository.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mStockRepositoryMockGetBySKU) When(ctx context.Context, sku int64) *StockRepositoryMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetBySKUExpectation{
		mock:               mmGetBySKU.mock,
		params:             &StockRepositoryMockGetBySKUParams{ctx, sku},
		expectationOrigins: StockRepositoryMockGetBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetBySKU return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetBySKUExpectation) Then(u1 uint32, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times StockRepository.GetBySKU should be invoked
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Times(n uint64) *mStockRepositoryMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of StockRepositoryMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	mmGetBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySKU
}

func (mmGetBySKU *mStockRepositoryMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements mm_service.StockRepository
func (mmGetBySKU *StockRepositoryMock) GetBySKU(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	mmGetBySKU.t.Helper()

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, sku)
	}

	mm_params := StockRepositoryMockGetBySKUParams{ctx, sku}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the StockRepositoryMock.GetBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, sku)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to StockRepositoryMock.GetBySKU. %v %v", ctx, sku)
	return
}

// GetBySKUAfterCounter returns a count of finished StockRepositoryMock.GetBySKU invocations
func (mmGetBySKU *StockRepositoryMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of StockRepositoryMock.GetBySKU invocations
func (mmGetBySKU *StockRepositoryMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Calls() []*StockRepositoryMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s", m.GetBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s with params: %#v", m.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s", m.funcGetBySKUOrigin)
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), m.GetBySKUMock.expectedInvocationsOrigin, afterGetBySKUCounter)
	}
}

type mStockRepositoryMockGetStock struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetStockExpectation
	expectations       []*StockRepositoryMockGetStockExpectation

	callArgs []*StockRepositoryMockGetStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetStockExpectation specifies expectation struct of the StockRepository.GetStock
type StockRepositoryMockGetStockExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetStockParams
	paramPtrs          *StockRepositoryMockGetStockParamPtrs
	expectationOrigins StockRepositoryMockGetStockExpectationOrigins
	results            *StockRepositoryMockGetStockResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetStockParams contains parameters of the StockRepository.GetStock
type StockRepositoryMockGetStockParams struct {
	ctx context.Context
	sku int64
}

// StockRepositoryMockGetStockParamPtrs contains pointers to parameters of the StockRepository.GetStock
type StockRepositoryMockGetStockParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// StockRepositoryMockGetStockResults contains results of the StockRepository.GetStock
type StockRepositoryMockGetStockResults struct {
	sp1 *model.Stock
	err error
}

// StockRepositoryMockGetStockOrigins contains origins of expectations of the StockRepository.GetStock
type StockRepositoryMockGetStockExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStock *mStockRepositoryMockGetStock) Optional() *mStockRepositoryMockGetStock {
	mmGetStock.optional = true
	return mmGetStock
}

// Expect sets up expected params for StockRepository.GetStock
func (mmGetStock *mStockRepositoryMockGetStock) Expect(ctx context.Context, sku int64) *mStockRepositoryMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &StockRepositoryMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.paramPtrs != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by ExpectParams functions")
	}

	mmGetStock.defaultExpectation.params = &StockRepositoryMockGetStockParams{ctx, sku}
	mmGetStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStock.expectations {
		if minimock.Equal(e.params, mmGetStock.defaultExpectation.params) {
			mmGetStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStock.defaultExpectation.params)
		}
	}

	return mmGetStock
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.GetStock
func (mmGetStock *mStockRepositoryMockGetStock) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &StockRepositoryMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.params != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Expect")
	}

	if mmGetStock.defaultExpectation.paramPtrs == nil {
		mmGetStock.defaultExpectation.paramPtrs = &StockRepositoryMockGetStockParamPtrs{}
	}
	mmGetStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStock
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.GetStock
func (mmGetStock *mStockRepositoryMockGetStock) ExpectSkuParam2(sku int64) *mStockRepositoryMockGetStock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &StockRepositoryMockGetStockExpectation{}
	}

	if mmGetStock.defaultExpectation.params != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Expect")
	}

	if mmGetStock.defaultExpectation.paramPtrs == nil {
		mmGetStock.defaultExpectation.paramPtrs = &StockRepositoryMockGetStockParamPtrs{}
	}
	mmGetStock.defaultExpectation.paramPtrs.sku = &sku
	mmGetStock.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetStock
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetStock
func (mmGetStock *mStockRepositoryMockGetStock) Inspect(f func(ctx context.Context, sku int64)) *mStockRepositoryMockGetStock {
	if mmGetStock.mock.inspectFuncGetStock != nil {
		mmGetStock.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetStock")
	}

	mmGetStock.mock.inspectFuncGetStock = f

	return mmGetStock
}

// Return sets up results that will be returned by StockRepository.GetStock
func (mmGetStock *mStockRepositoryMockGetStock) Return(sp1 *model.Stock, err error) *StockRepositoryMock {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Set")
	}

	if mmGetStock.defaultExpectation == nil {
		mmGetStock.defaultExpectation = &StockRepositoryMockGetStockExpectation{mock: mmGetStock.mock}
	}
	mmGetStock.defaultExpectation.results = &StockRepositoryMockGetStockResults{sp1, err}
	mmGetStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStock.mock
}

// Set uses given function f to mock the StockRepository.GetStock method
func (mmGetStock *mStockRepositoryMockGetStock) Set(f func(ctx context.Context, sku int64) (sp1 *model.Stock, err error)) *StockRepositoryMock {
	if mmGetStock.defaultExpectation != nil {
		mmGetStock.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetStock method")
	}

	if len(mmGetStock.expectations) > 0 {
		mmGetStock.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetStock method")
	}

	mmGetStock.mock.funcGetStock = f
	mmGetStock.mock.funcGetStockOrigin = minimock.CallerInfo(1)
	return mmGetStock.mock
}

// When sets expectation for the StockRepository.GetStock which will trigger the result defined by the following
// Then helper
func (mmGetStock *mStockRepositoryMockGetStock) When(ctx context.Context, sku int64) *StockRepositoryMockGetStockExpectation {
	if mmGetStock.mock.funcGetStock != nil {
		mmGetStock.mock.t.Fatalf("StockRepositoryMock.GetStock mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetStockExpectation{
		mock:               mmGetStock.mock,
		params:             &StockRepositoryMockGetStockParams{ctx, sku},
		expectationOrigins: StockRepositoryMockGetStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStock.expectations = append(mmGetStock.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetStock return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetStockExpectation) Then(sp1 *model.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetStockResults{sp1, err}
	return e.mock
}

// Times sets number of times StockRepository.GetStock should be invoked
func (mmGetStock *mStockRepositoryMockGetStock) Times(n uint64) *mStockRepositoryMockGetStock {
	if n == 0 {
		mmGetStock.mock.t.Fatalf("Times of StockRepositoryMock.GetStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStock.expectedInvocations, n)
	mmGetStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStock
}

func (mmGetStock *mStockRepositoryMockGetStock) invocationsDone() bool {
	if len(mmGetStock.expectations) == 0 && mmGetStock.defaultExpectation == nil && mmGetStock.mock.funcGetStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStock.mock.afterGetStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStock implements mm_service.StockRepository
func (mmGetStock *StockRepositoryMock) GetStock(ctx context.Context, sku int64) (sp1 *model.Stock, err error) {
	mm_atomic.AddUint64(&mmGetStock.beforeGetStockCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStock.afterGetStockCounter, 1)

	mmGetStock.t.Helper()

	if mmGetStock.inspectFuncGetStock != nil {
		mmGetStock.inspectFuncGetStock(ctx, sku)
	}

	mm_params := StockRepositoryMockGetStockParams{ctx, sku}

	// Record call args
	mmGetStock.GetStockMock.mutex.Lock()
	mmGetStock.GetStockMock.callArgs = append(mmGetStock.GetStockMock.callArgs, &mm_params)
	mmGetStock.GetStockMock.mutex.Unlock()

	for _, e := range mmGetStock.GetStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetStock.GetStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStock.GetStockMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStock.GetStockMock.defaultExpectation.params
		mm_want_ptrs := mmGetStock.GetStockMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetStockParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStock.t.Errorf("StockRepositoryMock.GetStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetStock.t.Errorf("StockRepositoryMock.GetStock got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStock.t.Errorf("StockRepositoryMock.GetStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStock.GetStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStock.GetStockMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStock.t.Fatal("No results are set for the StockRepositoryMock.GetStock")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetStock.funcGetStock != nil {
		return mmGetStock.funcGetStock(ctx, sku)
	}
	mmGetStock.t.Fatalf("Unexpected call to StockRepositoryMock.GetStock. %v %v", ctx, sku)
	return
}

// GetStockAfterCounter returns a count of finished StockRepositoryMock.GetStock invocations
func (mmGetStock *StockRepositoryMock) GetStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStock.afterGetStockCounter)
}

// GetStockBeforeCounter returns a count of StockRepositoryMock.GetStock invocations
func (mmGetStock *StockRepositoryMock) GetStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStock.beforeGetStockCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStock *mStockRepositoryMockGetStock) Calls() []*StockRepositoryMockGetStockParams {
	mmGetStock.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetStockParams, len(mmGetStock.callArgs))
	copy(argCopy, mmGetStock.callArgs)

	mmGetStock.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockDone returns true if the count of the GetStock invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetStockDone() bool {
	if m.GetStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockMock.invocationsDone()
}

// MinimockGetStockInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetStockInspect() {
	for _, e := range m.GetStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockCounter := mm_atomic.LoadUint64(&m.afterGetStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockMock.defaultExpectation != nil && afterGetStockCounter < 1 {
		if m.GetStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStock at\n%s", m.GetStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStock at\n%s with params: %#v", m.GetStockMock.defaultExpectation.expectationOrigins.origin, *m.GetStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStock != nil && afterGetStockCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetStock at\n%s", m.funcGetStockOrigin)
	}

	if !m.GetStockMock.invocationsDone() && afterGetStockCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockMock.expectedInvocations), m.GetStockMock.expectedInvocationsOrigin, afterGetStockCounter)
	}
}

type mStockRepositoryMockReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveExpectation
	expectations       []*StockRepositoryMockReserveExpectation

	callArgs []*StockRepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReserveExpectation specifies expectation struct of the StockRepository.Reserve
type StockRepositoryMockReserveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReserveParams
	paramPtrs          *StockRepositoryMockReserveParamPtrs
	expectationOrigins StockRepositoryMockReserveExpectationOrigins
	results            *StockRepositoryMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReserveParams contains parameters of the StockRepository.Reserve
type StockRepositoryMockReserveParams struct {
	ctx   context.Context
	items []model.Item
}

// StockRepositoryMockReserveParamPtrs contains pointers to parameters of the StockRepository.Reserve
type StockRepositoryMockReserveParamPtrs struct {
	ctx   *context.Context
	items *[]model.Item
}

// StockRepositoryMockReserveResults contains results of the StockRepository.Reserve
type StockRepositoryMockReserveResults struct {
	sa1 []model.Stock
	err error
}

// StockRepositoryMockReserveOrigins contains origins of expectations of the StockRepository.Reserve
type StockRepositoryMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockRepositoryMockReserve) Optional() *mStockRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Expect(ctx context.Context, items []model.Item) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockRepositoryMockReserveParams{ctx, items}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectItemsParam2 sets up expected param items for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectItemsParam2(items []model.Item) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.items = &items
	mmReserve.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Inspect(f func(ctx context.Context, items []model.Item)) *mStockRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Return(sa1 []model.Stock, err error) *StockRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockRepositoryMockReserveResults{sa1, err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the StockRepository.Reserve method
func (mmReserve *mStockRepositoryMockReserve) Set(f func(ctx context.Context, items []model.Item) (sa1 []model.Stock, err error)) *StockRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the StockRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockRepositoryMockReserve) When(ctx context.Context, items []model.Item) *StockRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &StockRepositoryMockReserveParams{ctx, items},
		expectationOrigins: StockRepositoryMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveExpectation) Then(sa1 []model.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveResults{sa1, err}
	return e.mock
}

// Times sets number of times StockRepository.Reserve should be invoked
func (mmReserve *mStockRepositoryMockReserve) Times(n uint64) *mStockRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockRepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mStockRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_service.StockRepository
func (mmReserve *StockRepositoryMock) Reserve(ctx context.Context, items []model.Item) (sa1 []model.Stock, err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := StockRepositoryMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockRepositoryMock.Reserve")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to StockRepositoryMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockRepositoryMockReserve) Calls() []*StockRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mStockRepositoryMockReserveCancel struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveCancelExpectation
	expectations       []*StockRepositoryMockReserveCancelExpectation

	callArgs []*StockRepositoryMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReserveCancelExpectation specifies expectation struct of the StockRepository.ReserveCancel
type StockRepositoryMockReserveCancelExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReserveCancelParams
	paramPtrs          *StockRepositoryMockReserveCancelParamPtrs
	expectationOrigins StockRepositoryMockReserveCancelExpectationOrigins
	results            *StockRepositoryMockReserveCancelResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReserveCancelParams contains parameters of the StockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParams struct {
	ctx   context.Context
	items []model.Item
}

// StockRepositoryMockReserveCancelParamPtrs contains pointers to parameters of the StockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParamPtrs struct {
	ctx   *context.Context
	items *[]model.Item
}

// StockRepositoryMockReserveCancelResults contains results of the StockRepository.ReserveCancel
type StockRepositoryMockReserveCancelResults struct {
	err error
}

// StockRepositoryMockReserveCancelOrigins contains origins of expectations of the StockRepository.ReserveCancel
type StockRepositoryMockReserveCancelExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Optional() *mStockRepositoryMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for StockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Expect(ctx context.Context, items []model.Item) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StockRepositoryMockReserveCancelParams{ctx, items}
	mmReserveCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectItemsParam2 sets up expected param items for StockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectItemsParam2(items []model.Item) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.items = &items
	mmReserveCancel.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Inspect(f func(ctx context.Context, items []model.Item)) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by StockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Return(err error) *StockRepositoryMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StockRepositoryMockReserveCancelResults{err}
	mmReserveCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// Set uses given function f to mock the StockRepository.ReserveCancel method
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Set(f func(ctx context.Context, items []model.Item) (err error)) *StockRepositoryMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the StockRepository.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the StockRepository.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	mmReserveCancel.mock.funcReserveCancelOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// When sets expectation for the StockRepository.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStockRepositoryMockReserveCancel) When(ctx context.Context, items []model.Item) *StockRepositoryMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveCancelExpectation{
		mock:               mmReserveCancel.mock,
		params:             &StockRepositoryMockReserveCancelParams{ctx, items},
		expectationOrigins: StockRepositoryMockReserveCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveCancelExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times StockRepository.ReserveCancel should be invoked
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Times(n uint64) *mStockRepositoryMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StockRepositoryMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	mmReserveCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancel
}

func (mmReserveCancel *mStockRepositoryMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements mm_service.StockRepository
func (mmReserveCancel *StockRepositoryMock) ReserveCancel(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	mmReserveCancel.t.Helper()

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, items)
	}

	mm_params := StockRepositoryMockReserveCancelParams{ctx, items}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveCancelParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StockRepositoryMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, items)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveCancel. %v %v", ctx, items)
	return
}

// ReserveCancelAfterCounter returns a count of finished StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Calls() []*StockRepositoryMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel at\n%s", m.ReserveCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel at\n%s with params: %#v", m.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel at\n%s", m.funcReserveCancelOrigin)
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), m.ReserveCancelMock.expectedInvocationsOrigin, afterReserveCancelCounter)
	}
}

type mStockRepositoryMockReserveRemove struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveRemoveExpectation
	expectations       []*StockRepositoryMockReserveRemoveExpectation

	callArgs []*StockRepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReserveRemoveExpectation specifies expectation struct of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReserveRemoveParams
	paramPtrs          *StockRepositoryMockReserveRemoveParamPtrs
	expectationOrigins StockRepositoryMockReserveRemoveExpectationOrigins
	results            *StockRepositoryMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReserveRemoveParams contains parameters of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParams struct {
	ctx   context.Context
	items []model.Item
}

// StockRepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	items *[]model.Item
}

// StockRepositoryMockReserveRemoveResults contains results of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveResults struct {
	err error
}

// StockRepositoryMockReserveRemoveOrigins contains origins of expectations of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Optional() *mStockRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Expect(ctx context.Context, items []model.Item) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockRepositoryMockReserveRemoveParams{ctx, items}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectItemsParam2 sets up expected param items for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectItemsParam2(items []model.Item) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.items = &items
	mmReserveRemove.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, items []model.Item)) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Return(err error) *StockRepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockRepositoryMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the StockRepository.ReserveRemove method
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Set(f func(ctx context.Context, items []model.Item) (err error)) *StockRepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the StockRepository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the StockRepository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the StockRepository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockRepositoryMockReserveRemove) When(ctx context.Context, items []model.Item) *StockRepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &StockRepositoryMockReserveRemoveParams{ctx, items},
		expectationOrigins: StockRepositoryMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveRemoveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times StockRepository.ReserveRemove should be invoked
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Times(n uint64) *mStockRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockRepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mStockRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_service.StockRepository
func (mmReserveRemove *StockRepositoryMock) ReserveRemove(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, items)
	}

	mm_params := StockRepositoryMockReserveRemoveParams{ctx, items}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveRemoveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockRepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, items)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveRemove. %v %v", ctx, items)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Calls() []*StockRepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

type mStockRepositoryMockUpdateStock struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockUpdateStockExpectation
	expectations       []*StockRepositoryMockUpdateStockExpectation

	callArgs []*StockRepositoryMockUpdateStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockUpdateStockExpectation specifies expectation struct of the StockRepository.UpdateStock
type StockRepositoryMockUpdateStockExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockUpdateStockParams
	paramPtrs          *StockRepositoryMockUpdateStockParamPtrs
	expectationOrigins StockRepositoryMockUpdateStockExpectationOrigins
	results            *StockRepositoryMockUpdateStockResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockUpdateStockParams contains parameters of the StockRepository.UpdateStock
type StockRepositoryMockUpdateStockParams struct {
	ctx   context.Context
	stock model.Stock
}

// StockRepositoryMockUpdateStockParamPtrs contains pointers to parameters of the StockRepository.UpdateStock
type StockRepositoryMockUpdateStockParamPtrs struct {
	ctx   *context.Context
	stock *model.Stock
}

// StockRepositoryMockUpdateStockResults contains results of the StockRepository.UpdateStock
type StockRepositoryMockUpdateStockResults struct {
	sp1 *model.Stock
	err error
}

// StockRepositoryMockUpdateStockOrigins contains origins of expectations of the StockRepository.UpdateStock
type StockRepositoryMockUpdateStockExpectationOrigins struct {
	origin      string
	originCtx   string
	originStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Optional() *mStockRepositoryMockUpdateStock {
	mmUpdateStock.optional = true
	return mmUpdateStock
}

// Expect sets up expected params for StockRepository.UpdateStock
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Expect(ctx context.Context, stock model.Stock) *mStockRepositoryMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &StockRepositoryMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.paramPtrs != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by ExpectParams functions")
	}

	mmUpdateStock.defaultExpectation.params = &StockRepositoryMockUpdateStockParams{ctx, stock}
	mmUpdateStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStock.expectations {
		if minimock.Equal(e.params, mmUpdateStock.defaultExpectation.params) {
			mmUpdateStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStock.defaultExpectation.params)
		}
	}

	return mmUpdateStock
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.UpdateStock
func (mmUpdateStock *mStockRepositoryMockUpdateStock) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &StockRepositoryMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.params != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Expect")
	}

	if mmUpdateStock.defaultExpectation.paramPtrs == nil {
		mmUpdateStock.defaultExpectation.paramPtrs = &StockRepositoryMockUpdateStockParamPtrs{}
	}
	mmUpdateStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStock
}

// ExpectStockParam2 sets up expected param stock for StockRepository.UpdateStock
func (mmUpdateStock *mStockRepositoryMockUpdateStock) ExpectStockParam2(stock model.Stock) *mStockRepositoryMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &StockRepositoryMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.params != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Expect")
	}

	if mmUpdateStock.defaultExpectation.paramPtrs == nil {
		mmUpdateStock.defaultExpectation.paramPtrs = &StockRepositoryMockUpdateStockParamPtrs{}
	}
	mmUpdateStock.defaultExpectation.paramPtrs.stock = &stock
	mmUpdateStock.defaultExpectation.expectationOrigins.originStock = minimock.CallerInfo(1)

	return mmUpdateStock
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.UpdateStock
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Inspect(f func(ctx context.Context, stock model.Stock)) *mStockRepositoryMockUpdateStock {
	if mmUpdateStock.mock.inspectFuncUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.UpdateStock")
	}

	mmUpdateStock.mock.inspectFuncUpdateStock = f

	return mmUpdateStock
}

// Return sets up results that will be returned by StockRepository.UpdateStock
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Return(sp1 *model.Stock, err error) *StockRepositoryMock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &StockRepositoryMockUpdateStockExpectation{mock: mmUpdateStock.mock}
	}
	mmUpdateStock.defaultExpectation.results = &StockRepositoryMockUpdateStockResults{sp1, err}
	mmUpdateStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStock.mock
}

// Set uses given function f to mock the StockRepository.UpdateStock method
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Set(f func(ctx context.Context, stock model.Stock) (sp1 *model.Stock, err error)) *StockRepositoryMock {
	if mmUpdateStock.defaultExpectation != nil {
		mmUpdateStock.mock.t.Fatalf("Default expectation is already set for the StockRepository.UpdateStock method")
	}

	if len(mmUpdateStock.expectations) > 0 {
		mmUpdateStock.mock.t.Fatalf("Some expectations are already set for the StockRepository.UpdateStock method")
	}

	mmUpdateStock.mock.funcUpdateStock = f
	mmUpdateStock.mock.funcUpdateStockOrigin = minimock.CallerInfo(1)
	return mmUpdateStock.mock
}

// When sets expectation for the StockRepository.UpdateStock which will trigger the result defined by the following
// Then helper
func (mmUpdateStock *mStockRepositoryMockUpdateStock) When(ctx context.Context, stock model.Stock) *StockRepositoryMockUpdateStockExpectation {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("StockRepositoryMock.UpdateStock mock is already set by Set")
	}

	expectation := &StockRepositoryMockUpdateStockExpectation{
		mock:               mmUpdateStock.mock,
		params:             &StockRepositoryMockUpdateStockParams{ctx, stock},
		expectationOrigins: StockRepositoryMockUpdateStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStock.expectations = append(mmUpdateStock.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.UpdateStock return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockUpdateStockExpectation) Then(sp1 *model.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockUpdateStockResults{sp1, err}
	return e.mock
}

// Times sets number of times StockRepository.UpdateStock should be invoked
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Times(n uint64) *mStockRepositoryMockUpdateStock {
	if n == 0 {
		mmUpdateStock.mock.t.Fatalf("Times of StockRepositoryMock.UpdateStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStock.expectedInvocations, n)
	mmUpdateStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStock
}

func (mmUpdateStock *mStockRepositoryMockUpdateStock) invocationsDone() bool {
	if len(mmUpdateStock.expectations) == 0 && mmUpdateStock.defaultExpectation == nil && mmUpdateStock.mock.funcUpdateStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStock.mock.afterUpdateStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStock implements mm_service.StockRepository
func (mmUpdateStock *StockRepositoryMock) UpdateStock(ctx context.Context, stock model.Stock) (sp1 *model.Stock, err error) {
	mm_atomic.AddUint64(&mmUpdateStock.beforeUpdateStockCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStock.afterUpdateStockCounter, 1)

	mmUpdateStock.t.Helper()

	if mmUpdateStock.inspectFuncUpdateStock != nil {
		mmUpdateStock.inspectFuncUpdateStock(ctx, stock)
	}

	mm_params := StockRepositoryMockUpdateStockParams{ctx, stock}

	// Record call args
	mmUpdateStock.UpdateStockMock.mutex.Lock()
	mmUpdateStock.UpdateStockMock.callArgs = append(mmUpdateStock.UpdateStockMock.callArgs, &mm_params)
	mmUpdateStock.UpdateStockMock.mutex.Unlock()

	for _, e := range mmUpdateStock.UpdateStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUpdateStock.UpdateStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStock.UpdateStockMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStock.UpdateStockMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStock.UpdateStockMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockUpdateStockParams{ctx, stock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStock.t.Errorf("StockRepositoryMock.UpdateStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stock != nil && !minimock.Equal(*mm_want_ptrs.stock, mm_got.stock) {
				mmUpdateStock.t.Errorf("StockRepositoryMock.UpdateStock got unexpected parameter stock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.originStock, *mm_want_ptrs.stock, mm_got.stock, minimock.Diff(*mm_want_ptrs.stock, mm_got.stock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStock.t.Errorf("StockRepositoryMock.UpdateStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStock.UpdateStockMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStock.t.Fatal("No results are set for the StockRepositoryMock.UpdateStock")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUpdateStock.funcUpdateStock != nil {
		return mmUpdateStock.funcUpdateStock(ctx, stock)
	}
	mmUpdateStock.t.Fatalf("Unexpected call to StockRepositoryMock.UpdateStock. %v %v", ctx, stock)
	return
}

// UpdateStockAfterCounter returns a count of finished StockRepositoryMock.UpdateStock invocations
func (mmUpdateStock *StockRepositoryMock) UpdateStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStock.afterUpdateStockCounter)
}

// UpdateStockBeforeCounter returns a count of StockRepositoryMock.UpdateStock invocations
func (mmUpdateStock *StockRepositoryMock) UpdateStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStock.beforeUpdateStockCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.UpdateStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStock *mStockRepositoryMockUpdateStock) Calls() []*StockRepositoryMockUpdateStockParams {
	mmUpdateStock.mutex.RLock()

	argCopy := make([]*StockRepositoryMockUpdateStockParams, len(mmUpdateStock.callArgs))
	copy(argCopy, mmUpdateStock.callArgs)

	mmUpdateStock.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStockDone returns true if the count of the UpdateStock invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockUpdateStockDone() bool {
	if m.UpdateStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStockMock.invocationsDone()
}

// MinimockUpdateStockInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockUpdateStockInspect() {
	for _, e := range m.UpdateStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStockCounter := mm_atomic.LoadUint64(&m.afterUpdateStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStockMock.defaultExpectation != nil && afterUpdateStockCounter < 1 {
		if m.UpdateStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStock at\n%s", m.UpdateStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStock at\n%s with params: %#v", m.UpdateStockMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStock != nil && afterUpdateStockCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.UpdateStock at\n%s", m.funcUpdateStockOrigin)
	}

	if !m.UpdateStockMock.invocationsDone() && afterUpdateStockCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.UpdateStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStockMock.expectedInvocations), m.UpdateStockMock.expectedInvocationsOrigin, afterUpdateStockCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockGetStockInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()

			m.MinimockUpdateStockInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockGetStockDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone() &&
		m.MinimockUpdateStockDone()
}
